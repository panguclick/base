// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_CHROME_TRACK_EVENT_PROTO_H_
#define PERFETTO_PROTOS_CHROME_TRACK_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"
#include "protos/perfetto/trace/track_event/debug_annotation.pbzero.h"
#include "protos/perfetto/trace/track_event/track_event.pbzero.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AndroidActivity;
class AndroidView;
class BrowsingContextState;
class ChromeBrowserContext;
class FrameTreeNodeInfo;
class GlobalRenderFrameHostId;
class RenderFrameHost;
class RenderProcessHost;
class SiteInstance;
class SiteInstanceGroup;
enum BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason : int32_t;
enum ChildProcessLauncherPriority_Importance : int32_t;
enum ChromeSamplingProfilerSampleCollected_WriteStatus : int32_t;
enum ChromeThreadPoolTask_ExecutionMode : int32_t;
enum ChromeThreadPoolTask_Priority : int32_t;
enum ChromeThreadPoolTask_ShutdownBehavior : int32_t;
enum EventLatency_EventType : int32_t;
enum FrameDeleteIntention : int32_t;
enum MemoryPressureLevel : int32_t;
enum ProcessSingleton_RemoteHungProcessTerminateReason : int32_t;
enum ProcessSingleton_RemoteProcessInteractionResult : int32_t;
enum RenderFrameHost_LifecycleState : int32_t;
enum RendererMainThreadTaskExecution_FrameType : int32_t;
enum RendererMainThreadTaskExecution_TaskType : int32_t;
enum ShouldSwapBrowsingInstance : int32_t;

enum ChromeAppState : int32_t {
  APP_STATE_FOREGROUND = 1,
  APP_STATE_BACKGROUND = 2,
};

const ChromeAppState ChromeAppState_MIN = APP_STATE_FOREGROUND;
const ChromeAppState ChromeAppState_MAX = APP_STATE_BACKGROUND;

enum MemoryPressureLevel : int32_t {
  MEMORY_PRESSURE_LEVEL_NONE = 0,
  MEMORY_PRESSURE_LEVEL_MODERATE = 1,
  MEMORY_PRESSURE_LEVEL_CRITICAL = 2,
};

const MemoryPressureLevel MemoryPressureLevel_MIN = MEMORY_PRESSURE_LEVEL_NONE;
const MemoryPressureLevel MemoryPressureLevel_MAX = MEMORY_PRESSURE_LEVEL_CRITICAL;

enum FrameDeleteIntention : int32_t {
  FRAME_DELETE_INTENTION_NOT_MAIN_FRAME = 0,
  FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_SHUTDOWN = 1,
  FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_NAVIGATION_CANCELLED = 2,
};

const FrameDeleteIntention FrameDeleteIntention_MIN = FRAME_DELETE_INTENTION_NOT_MAIN_FRAME;
const FrameDeleteIntention FrameDeleteIntention_MAX = FRAME_DELETE_INTENTION_SPECULATIVE_MAIN_FRAME_FOR_NAVIGATION_CANCELLED;

enum ShouldSwapBrowsingInstance : int32_t {
  SHOULD_SWAP_BROWSING_INSTANCE_NO = 0,
  SHOULD_SWAP_BROWSING_INSTANCE_YES_FORCE_SWAP = 1,
  SHOULD_SWAP_BROWSING_INSTANCE_YES_CROSS_SITE_PROACTIVE_SWAP = 2,
  SHOULD_SWAP_BROWSING_INSTANCE_YES_SAME_SITE_PROACTIVE_SWAP = 3,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_PROACTIVE_SWAP_DISABLED = 4,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_MAIN_FRAME = 5,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_HAS_RELATED_ACTIVE_CONTENTS = 6,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_DOES_NOT_HAVE_SITE = 7,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_SOURCE_URL_SCHEME_NOT_HTTP_OR_HTTPS = 8,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_DESTINATION_URL_SCHEME_NOT_HTTP_OR_HTTPS = 9,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_SITE_NAVIGATION = 10,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_RELOADING_ERROR_PAGE = 11,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_ALREADY_HAS_MATCHING_BROWSING_INSTANCE = 12,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_RENDERER_DEBUG_URL = 13,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_NEEDED_FOR_BACK_FORWARD_CACHE = 14,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_DOCUMENT_NAVIGATION = 15,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_SAME_URL_NAVIGATION = 16,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_WILL_REPLACE_ENTRY = 17,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_RELOAD = 18,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_GUEST = 19,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_HAS_NOT_COMMITTED_ANY_NAVIGATION = 20,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_UNLOAD_HANDLER_EXISTS_ON_SAME_SITE_NAVIGATION = 21,
  SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_PRIMARY_MAIN_FRAME = 22,
};

const ShouldSwapBrowsingInstance ShouldSwapBrowsingInstance_MIN = SHOULD_SWAP_BROWSING_INSTANCE_NO;
const ShouldSwapBrowsingInstance ShouldSwapBrowsingInstance_MAX = SHOULD_SWAP_BROWSING_INSTANCE_NO_NOT_PRIMARY_MAIN_FRAME;

enum DeviceThermalState : int32_t {
  DEVICE_THERMAL_STATE_UNKNOWN = 0,
  DEVICE_THERMAL_STATE_NOMINAL = 1,
  DEVICE_THERMAL_STATE_FAIR = 2,
  DEVICE_THERMAL_STATE_SERIOUS = 3,
  DEVICE_THERMAL_STATE_CRITICAL = 4,
};

const DeviceThermalState DeviceThermalState_MIN = DEVICE_THERMAL_STATE_UNKNOWN;
const DeviceThermalState DeviceThermalState_MAX = DEVICE_THERMAL_STATE_CRITICAL;

enum ProcessSingleton_RemoteProcessInteractionResult : int32_t {
  ProcessSingleton_RemoteProcessInteractionResult_INTERACTION_RESULT_UNSPECIFIED = 0,
  ProcessSingleton_RemoteProcessInteractionResult_TERMINATE_FAILED = 1,
  ProcessSingleton_RemoteProcessInteractionResult_REMOTE_PROCESS_NOT_FOUND = 2,
  ProcessSingleton_RemoteProcessInteractionResult_TERMINATE_WAIT_TIMEOUT = 3,
  ProcessSingleton_RemoteProcessInteractionResult_RUNNING_PROCESS_NOTIFY_ERROR = 4,
  ProcessSingleton_RemoteProcessInteractionResult_TERMINATE_NOT_ENOUGH_PERMISSIONS = 5,
  ProcessSingleton_RemoteProcessInteractionResult_REMOTE_PROCESS_SHUTTING_DOWN = 6,
  ProcessSingleton_RemoteProcessInteractionResult_PROFILE_UNLOCKED = 7,
  ProcessSingleton_RemoteProcessInteractionResult_PROFILE_UNLOCKED_BEFORE_KILL = 8,
  ProcessSingleton_RemoteProcessInteractionResult_SAME_BROWSER_INSTANCE = 9,
  ProcessSingleton_RemoteProcessInteractionResult_SAME_BROWSER_INSTANCE_BEFORE_KILL = 10,
  ProcessSingleton_RemoteProcessInteractionResult_FAILED_TO_EXTRACT_PID = 11,
  ProcessSingleton_RemoteProcessInteractionResult_INVALID_LOCK_FILE = 12,
  ProcessSingleton_RemoteProcessInteractionResult_ORPHANED_LOCK_FILE = 13,
  ProcessSingleton_RemoteProcessInteractionResult_USER_REFUSED_TERMINATION = 14,
  ProcessSingleton_RemoteProcessInteractionResult_TERMINATE_SUCCEEDED = 100,
};

const ProcessSingleton_RemoteProcessInteractionResult ProcessSingleton_RemoteProcessInteractionResult_MIN = ProcessSingleton_RemoteProcessInteractionResult_INTERACTION_RESULT_UNSPECIFIED;
const ProcessSingleton_RemoteProcessInteractionResult ProcessSingleton_RemoteProcessInteractionResult_MAX = ProcessSingleton_RemoteProcessInteractionResult_TERMINATE_SUCCEEDED;

enum ProcessSingleton_RemoteHungProcessTerminateReason : int32_t {
  ProcessSingleton_RemoteHungProcessTerminateReason_TERMINATE_REASON_UNSPECIFIED = 0,
  ProcessSingleton_RemoteHungProcessTerminateReason_USER_ACCEPTED_TERMINATION = 1,
  ProcessSingleton_RemoteHungProcessTerminateReason_NO_VISIBLE_WINDOW_FOUND = 2,
  ProcessSingleton_RemoteHungProcessTerminateReason_NOTIFY_ATTEMPTS_EXCEEDED = 3,
  ProcessSingleton_RemoteHungProcessTerminateReason_SOCKET_WRITE_FAILED = 4,
  ProcessSingleton_RemoteHungProcessTerminateReason_SOCKET_READ_FAILED = 5,
};

const ProcessSingleton_RemoteHungProcessTerminateReason ProcessSingleton_RemoteHungProcessTerminateReason_MIN = ProcessSingleton_RemoteHungProcessTerminateReason_TERMINATE_REASON_UNSPECIFIED;
const ProcessSingleton_RemoteHungProcessTerminateReason ProcessSingleton_RemoteHungProcessTerminateReason_MAX = ProcessSingleton_RemoteHungProcessTerminateReason_SOCKET_READ_FAILED;

enum EventLatency_EventType : int32_t {
  EventLatency_EventType_EVENT_TYPE_UNSPECIFIED = 0,
  EventLatency_EventType_MOUSE_PRESSED = 1,
  EventLatency_EventType_MOUSE_RELEASED = 2,
  EventLatency_EventType_MOUSE_WHEEL = 3,
  EventLatency_EventType_KEY_PRESSED = 4,
  EventLatency_EventType_KEY_RELEASED = 5,
  EventLatency_EventType_TOUCH_PRESSED = 6,
  EventLatency_EventType_TOUCH_RELEASED = 7,
  EventLatency_EventType_TOUCH_MOVED = 8,
  EventLatency_EventType_GESTURE_SCROLL_BEGIN = 9,
  EventLatency_EventType_GESTURE_SCROLL_UPDATE = 10,
  EventLatency_EventType_GESTURE_SCROLL_END = 11,
  EventLatency_EventType_GESTURE_DOUBLE_TAP = 12,
  EventLatency_EventType_GESTURE_LONG_PRESS = 13,
  EventLatency_EventType_GESTURE_LONG_TAP = 14,
  EventLatency_EventType_GESTURE_SHOW_PRESS = 15,
  EventLatency_EventType_GESTURE_TAP = 16,
  EventLatency_EventType_GESTURE_TAP_CANCEL = 17,
  EventLatency_EventType_GESTURE_TAP_DOWN = 18,
  EventLatency_EventType_GESTURE_TAP_UNCONFIRMED = 19,
  EventLatency_EventType_GESTURE_TWO_FINGER_TAP = 20,
  EventLatency_EventType_FIRST_GESTURE_SCROLL_UPDATE = 21,
  EventLatency_EventType_MOUSE_DRAGGED = 22,
  EventLatency_EventType_GESTURE_PINCH_BEGIN = 23,
  EventLatency_EventType_GESTURE_PINCH_END = 24,
  EventLatency_EventType_GESTURE_PINCH_UPDATE = 25,
  EventLatency_EventType_INERTIAL_GESTURE_SCROLL_UPDATE = 26,
};

const EventLatency_EventType EventLatency_EventType_MIN = EventLatency_EventType_EVENT_TYPE_UNSPECIFIED;
const EventLatency_EventType EventLatency_EventType_MAX = EventLatency_EventType_INERTIAL_GESTURE_SCROLL_UPDATE;

enum RendererMainThreadTaskExecution_TaskType : int32_t {
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_UNKNOWN = 0,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_DOM_MANIPULATION = 1,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_USER_INTERACTION = 2,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_NETWORKING = 3,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_NETWORKING_CONTROL = 4,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_HISTORY_TRAVERSAL = 5,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_EMBED = 6,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MEDIA_ELEMENT_EVENT = 7,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_CANVAS_BLOB_SERIALIZATION = 8,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MICROTASK = 9,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_HIGH_NESTING = 10,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_REMOTE_EVENT = 11,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WEB_SOCKET = 12,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_POSTED_MESSAGE = 13,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_UNSHIPPED_PORT_MESSAGE = 14,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_FILE_READING = 15,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_DATABASE_ACCESS = 16,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_PRESENTATION = 17,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_SENSOR = 18,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_PERFORMANCE_TIMELINE = 19,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WEB_GL = 20,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_IDLE_TASK = 21,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MISC_PLATFORM_API = 22,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_DEFAULT = 23,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_LOADING = 24,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_TEST = 26,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_WEB_CRYPTO = 27,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_MEDIA = 29,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_MEDIA_REALTIME = 30,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_USER_INTERACTION = 32,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_INSPECTOR = 33,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_V8 = 37,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_COMPOSITOR = 38,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_DEFAULT = 39,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_INPUT = 40,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IDLE = 41,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_CONTROL = 43,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_INTERSECTION_OBSERVER = 44,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_DEFAULT = 45,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WORKER_THREAD_TASK_QUEUE_DEFAULT = 46,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WORKER_THREAD_TASK_QUEUE_V8 = 47,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WORKER_THREAD_TASK_QUEUE_COMPOSITOR = 48,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_INPUT = 49,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_NETWORKING_WITH_URL_LOADER_ANNOTATION = 50,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WORKER_ANIMATION = 51,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_TRANSLATION = 55,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_FONT_LOADING = 56,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_APPLICATION_LIFECYCLE = 57,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_BACKGROUND_FETCH = 58,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_PERMISSION = 59,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_SERVICE_WORKER_CLIENT_MESSAGE = 60,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_CONTENT_CAPTURE = 61,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_MEMORY_PURGE = 62,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED = 63,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED_UNFREEZABLE = 64,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_CONTINUE_SCRIPT_LOADING = 65,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WEB_LOCKS = 66,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WEB_SCHEDULING_POSTED_TASK = 67,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_FRAME_LIFE_CYCLE_CONTROL = 68,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_NON_WAKING = 69,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_FIND_IN_PAGE = 70,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_HIGH_PRIORITY_LOCAL_FRAME = 71,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_JAVASCRIPT_TIMER_IMMEDIATE = 72,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_LOW_NESTING = 73,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IPC_TRACKING = 74,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_NETWORKING_UNFREEZABLE = 75,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WAKE_LOCK = 76,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_INPUT_BLOCKING = 77,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WEB_GPU = 78,
  RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_POST_MESSAGE_FORWARDING = 79,
};

const RendererMainThreadTaskExecution_TaskType RendererMainThreadTaskExecution_TaskType_MIN = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_UNKNOWN;
const RendererMainThreadTaskExecution_TaskType RendererMainThreadTaskExecution_TaskType_MAX = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_POST_MESSAGE_FORWARDING;

enum RendererMainThreadTaskExecution_FrameType : int32_t {
  RendererMainThreadTaskExecution_FrameType_FRAME_TYPE_UNSPECIFIED = 0,
  RendererMainThreadTaskExecution_FrameType_FRAME_TYPE_MAIN_FRAME = 1,
  RendererMainThreadTaskExecution_FrameType_FRAME_TYPE_SAME_ORIGIN_SUBFRAME = 2,
  RendererMainThreadTaskExecution_FrameType_FRAME_TYPE_CROSS_ORIGIN_SUBFRAME = 3,
};

const RendererMainThreadTaskExecution_FrameType RendererMainThreadTaskExecution_FrameType_MIN = RendererMainThreadTaskExecution_FrameType_FRAME_TYPE_UNSPECIFIED;
const RendererMainThreadTaskExecution_FrameType RendererMainThreadTaskExecution_FrameType_MAX = RendererMainThreadTaskExecution_FrameType_FRAME_TYPE_CROSS_ORIGIN_SUBFRAME;

enum BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason : int32_t {
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NOT_MAIN_FRAME = 1,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BACK_FORWARD_CACHE_DISABLED = 2,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_RELATED_ACTIVE_CONTENTS_EXIST = 3,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_HTTP_STATUS_NOT_OK = 4,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SCHEME_NOT_HTTP_OR_HTTPS = 5,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_LOADING = 6,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_WAS_GRANTED_MEDIA_ACCESS = 7,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BLOCKLISTED_FEATURES = 8,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_DISABLE_FOR_RENDER_FRAME_HOST_CALLED = 9,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_DOMAIN_NOT_ALLOWED = 10,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_HTTP_METHOD_NOT_GET = 11,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SUBFRAME_IS_NAVIGATING = 12,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_TIMEOUT = 13,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CACHE_LIMIT = 14,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_JAVASCRIPT_EXECUTION = 15,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_RENDERER_PROCESS_KILLED = 16,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_RENDERER_PROCESS_CRASHED = 17,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_GRANTED_MEDIA_STREAM_ACCESS = 19,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SCHEDULER_TRACKED_FEATURE_USED = 20,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CONFLICTING_BROWSING_INSTANCE = 21,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CACHE_FLUSHED = 22,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SERVICE_WORKER_VERSION_ACTIVATION = 23,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SESSION_RESTORED = 24,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_UNKNOWN = 25,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SERVICE_WORKER_POST_MESSAGE = 26,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_ENTERED_BACK_FORWARD_CACHE_BEFORE_SERVICE_WORKER_HOST_ADDED = 27,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NOT_MOST_RECENT_NAVIGATION_ENTRY = 28,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SERVICE_WORKER_CLAIM = 29,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_IGNORE_EVENT_AND_EVICT = 30,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_HAVE_INNER_CONTENTS = 31,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_TIMEOUT_PUTTING_IN_CACHE = 32,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BACK_FORWARD_CACHE_DISABLED_BY_LOW_MEMORY = 33,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BACK_FORWARD_CACHE_DISABLED_BY_COMMAND_LINE = 34,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NETWORK_REQUEST_REDIRECTED = 35,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NETWORK_REQUEST_TIMEOUT = 36,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NETWORK_EXCEEDS_BUFFER_LIMIT = 37,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NAVIGATION_CANCELLED_WHILE_RESTORING = 38,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BACK_FORWARD_CACHE_DISABLED_FOR_PRERENDER = 39,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_USER_AGENT_OVERRIDE_DIFFERS = 40,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NETWORK_REQUEST_DATAPIPE_DRAINED_AS_BYTES_CONSUMER = 41,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_FOREGROUND_CACHE_LIMIT = 42,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BROWSING_INSTANCE_NOT_SWAPPED = 43,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BACK_FORWARD_CACHE_DISABLED_FOR_DELEGATE = 44,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_OPT_IN_UNLOAD_HEADER_NOT_PRESENT = 45,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_UNLOAD_HANDLER_EXISTS_IN_MAIN_FRAME = 46,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_UNLOAD_HANDLER_EXISTS_IN_SUBFRAME = 47,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SERVICE_WORKER_UNREGISTRATION = 48,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CACHE_CONTROL_NO_STORE = 49,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CACHE_CONTROL_NO_STORE_COOKIE_MODIFIED = 50,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CACHE_CONTROL_NO_STORE_HTTP_ONLY_COOKIE_MODIFIED = 51,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NO_RESPONSE_HEAD = 52,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_ACTIVATION_NAVIGATION_DISALLOWED_FOR_BUG_1234857 = 53,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_ERROR_DOCUMENT = 54,
  BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_FENCED_FRAMES_EMBEDDER = 55,
};

const BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_MIN = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NOT_MAIN_FRAME;
const BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_MAX = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_FENCED_FRAMES_EMBEDDER;

enum ChromeThreadPoolTask_Priority : int32_t {
  ChromeThreadPoolTask_Priority_PRIORITY_UNSPECIFIED = 0,
  ChromeThreadPoolTask_Priority_PRIORITY_BEST_EFFORT = 1,
  ChromeThreadPoolTask_Priority_PRIORITY_USER_VISIBLE = 2,
  ChromeThreadPoolTask_Priority_PRIORITY_USER_BLOCKING = 3,
};

const ChromeThreadPoolTask_Priority ChromeThreadPoolTask_Priority_MIN = ChromeThreadPoolTask_Priority_PRIORITY_UNSPECIFIED;
const ChromeThreadPoolTask_Priority ChromeThreadPoolTask_Priority_MAX = ChromeThreadPoolTask_Priority_PRIORITY_USER_BLOCKING;

enum ChromeThreadPoolTask_ExecutionMode : int32_t {
  ChromeThreadPoolTask_ExecutionMode_EXECTUION_MODE_UNSPECIFIED = 0,
  ChromeThreadPoolTask_ExecutionMode_EXECUTION_MODE_PARALLEL = 1,
  ChromeThreadPoolTask_ExecutionMode_EXECUTION_MODE_SEQUENCED = 2,
  ChromeThreadPoolTask_ExecutionMode_EXECUTION_MODE_SINGLE_THREAD = 3,
  ChromeThreadPoolTask_ExecutionMode_EXECUTION_MODE_JOB = 4,
};

const ChromeThreadPoolTask_ExecutionMode ChromeThreadPoolTask_ExecutionMode_MIN = ChromeThreadPoolTask_ExecutionMode_EXECTUION_MODE_UNSPECIFIED;
const ChromeThreadPoolTask_ExecutionMode ChromeThreadPoolTask_ExecutionMode_MAX = ChromeThreadPoolTask_ExecutionMode_EXECUTION_MODE_JOB;

enum ChromeThreadPoolTask_ShutdownBehavior : int32_t {
  ChromeThreadPoolTask_ShutdownBehavior_SHUTDOWN_BEHAVIOR_UNSPECIFIED = 0,
  ChromeThreadPoolTask_ShutdownBehavior_SHUTDOWN_BEHAVIOR_CONTINUE_ON_SHUTDOWN = 1,
  ChromeThreadPoolTask_ShutdownBehavior_SHUTDOWN_BEHAVIOR_SKIP_ON_SHUTDOWN = 2,
  ChromeThreadPoolTask_ShutdownBehavior_SHUTDOWN_BEHAVIOR_BLOCK_SHUTDOWN = 3,
};

const ChromeThreadPoolTask_ShutdownBehavior ChromeThreadPoolTask_ShutdownBehavior_MIN = ChromeThreadPoolTask_ShutdownBehavior_SHUTDOWN_BEHAVIOR_UNSPECIFIED;
const ChromeThreadPoolTask_ShutdownBehavior ChromeThreadPoolTask_ShutdownBehavior_MAX = ChromeThreadPoolTask_ShutdownBehavior_SHUTDOWN_BEHAVIOR_BLOCK_SHUTDOWN;

enum RenderFrameHost_LifecycleState : int32_t {
  RenderFrameHost_LifecycleState_UNSPECIFIED = 0,
  RenderFrameHost_LifecycleState_SPECULATIVE = 1,
  RenderFrameHost_LifecycleState_PENDING_COMMIT = 2,
  RenderFrameHost_LifecycleState_PRERENDERING = 3,
  RenderFrameHost_LifecycleState_ACTIVE = 4,
  RenderFrameHost_LifecycleState_IN_BACK_FORWARD_CACHE = 5,
  RenderFrameHost_LifecycleState_RUNNING_UNLOAD_HANDLERS = 6,
  RenderFrameHost_LifecycleState_READY_TO_BE_DELETED = 7,
};

const RenderFrameHost_LifecycleState RenderFrameHost_LifecycleState_MIN = RenderFrameHost_LifecycleState_UNSPECIFIED;
const RenderFrameHost_LifecycleState RenderFrameHost_LifecycleState_MAX = RenderFrameHost_LifecycleState_READY_TO_BE_DELETED;

enum ChromeSamplingProfilerSampleCollected_WriteStatus : int32_t {
  ChromeSamplingProfilerSampleCollected_WriteStatus_WRITE_STATUS_NONE = 0,
  ChromeSamplingProfilerSampleCollected_WriteStatus_WRITE_STATUS_BUFFERING_SAMPLE = 1,
  ChromeSamplingProfilerSampleCollected_WriteStatus_WRITE_STATUS_WRITING_BUFFERED = 2,
  ChromeSamplingProfilerSampleCollected_WriteStatus_WRITE_STATUS_WRITING_TO_TRACE = 3,
};

const ChromeSamplingProfilerSampleCollected_WriteStatus ChromeSamplingProfilerSampleCollected_WriteStatus_MIN = ChromeSamplingProfilerSampleCollected_WriteStatus_WRITE_STATUS_NONE;
const ChromeSamplingProfilerSampleCollected_WriteStatus ChromeSamplingProfilerSampleCollected_WriteStatus_MAX = ChromeSamplingProfilerSampleCollected_WriteStatus_WRITE_STATUS_WRITING_TO_TRACE;

enum ChildProcessLauncherPriority_Importance : int32_t {
  ChildProcessLauncherPriority_Importance_IMPORTANCE_NORMAL = 1,
  ChildProcessLauncherPriority_Importance_IMPORTANCE_MODERATE = 2,
  ChildProcessLauncherPriority_Importance_IMPORTANCE_IMPORTANT = 3,
};

const ChildProcessLauncherPriority_Importance ChildProcessLauncherPriority_Importance_MIN = ChildProcessLauncherPriority_Importance_IMPORTANCE_NORMAL;
const ChildProcessLauncherPriority_Importance ChildProcessLauncherPriority_Importance_MAX = ChildProcessLauncherPriority_Importance_IMPORTANCE_IMPORTANT;

class NavigationHandle_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  NavigationHandle_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit NavigationHandle_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit NavigationHandle_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_navigation_id() const { return at<1>().valid(); }
  int64_t navigation_id() const { return at<1>().as_int64(); }
  bool has_has_committed() const { return at<2>().valid(); }
  bool has_committed() const { return at<2>().as_bool(); }
  bool has_is_error_page() const { return at<3>().valid(); }
  bool is_error_page() const { return at<3>().as_bool(); }
  bool has_frame_tree_node() const { return at<4>().valid(); }
  ::protozero::ConstBytes frame_tree_node() const { return at<4>().as_bytes(); }
  bool has_render_frame_host() const { return at<5>().valid(); }
  ::protozero::ConstBytes render_frame_host() const { return at<5>().as_bytes(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class NavigationHandle : public ::protozero::Message {
 public:
  using Decoder = NavigationHandle_Decoder;
  enum : int32_t {
    kNavigationIdFieldNumber = 1,
    kHasCommittedFieldNumber = 2,
    kIsErrorPageFieldNumber = 3,
    kFrameTreeNodeFieldNumber = 4,
    kRenderFrameHostFieldNumber = 5,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.NavigationHandle"; }


  using FieldMetadata_NavigationId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_NavigationId kNavigationId() { return {}; }
  void set_navigation_id(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_NavigationId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasCommitted =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasCommitted kHasCommitted() { return {}; }
  void set_has_committed(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasCommitted::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsErrorPage =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsErrorPage kIsErrorPage() { return {}; }
  void set_is_error_page(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsErrorPage::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrameTreeNode =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FrameTreeNodeInfo,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNode kFrameTreeNode() { return {}; }
  template <typename T = FrameTreeNodeInfo> T* set_frame_tree_node() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_RenderFrameHost =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderFrameHost kRenderFrameHost() { return {}; }
  template <typename T = RenderFrameHost> T* set_render_frame_host() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      NavigationHandle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class ProcessSingleton_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProcessSingleton_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessSingleton_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessSingleton_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_remote_process_interaction_result() const { return at<1>().valid(); }
  int32_t remote_process_interaction_result() const { return at<1>().as_int32(); }
  bool has_remote_process_terminate_reason() const { return at<2>().valid(); }
  int32_t remote_process_terminate_reason() const { return at<2>().as_int32(); }
};

class ProcessSingleton : public ::protozero::Message {
 public:
  using Decoder = ProcessSingleton_Decoder;
  enum : int32_t {
    kRemoteProcessInteractionResultFieldNumber = 1,
    kRemoteProcessTerminateReasonFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ProcessSingleton"; }

  using RemoteProcessInteractionResult = ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult;
  using RemoteHungProcessTerminateReason = ::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason;
  static const RemoteProcessInteractionResult INTERACTION_RESULT_UNSPECIFIED = ProcessSingleton_RemoteProcessInteractionResult_INTERACTION_RESULT_UNSPECIFIED;
  static const RemoteProcessInteractionResult TERMINATE_FAILED = ProcessSingleton_RemoteProcessInteractionResult_TERMINATE_FAILED;
  static const RemoteProcessInteractionResult REMOTE_PROCESS_NOT_FOUND = ProcessSingleton_RemoteProcessInteractionResult_REMOTE_PROCESS_NOT_FOUND;
  static const RemoteProcessInteractionResult TERMINATE_WAIT_TIMEOUT = ProcessSingleton_RemoteProcessInteractionResult_TERMINATE_WAIT_TIMEOUT;
  static const RemoteProcessInteractionResult RUNNING_PROCESS_NOTIFY_ERROR = ProcessSingleton_RemoteProcessInteractionResult_RUNNING_PROCESS_NOTIFY_ERROR;
  static const RemoteProcessInteractionResult TERMINATE_NOT_ENOUGH_PERMISSIONS = ProcessSingleton_RemoteProcessInteractionResult_TERMINATE_NOT_ENOUGH_PERMISSIONS;
  static const RemoteProcessInteractionResult REMOTE_PROCESS_SHUTTING_DOWN = ProcessSingleton_RemoteProcessInteractionResult_REMOTE_PROCESS_SHUTTING_DOWN;
  static const RemoteProcessInteractionResult PROFILE_UNLOCKED = ProcessSingleton_RemoteProcessInteractionResult_PROFILE_UNLOCKED;
  static const RemoteProcessInteractionResult PROFILE_UNLOCKED_BEFORE_KILL = ProcessSingleton_RemoteProcessInteractionResult_PROFILE_UNLOCKED_BEFORE_KILL;
  static const RemoteProcessInteractionResult SAME_BROWSER_INSTANCE = ProcessSingleton_RemoteProcessInteractionResult_SAME_BROWSER_INSTANCE;
  static const RemoteProcessInteractionResult SAME_BROWSER_INSTANCE_BEFORE_KILL = ProcessSingleton_RemoteProcessInteractionResult_SAME_BROWSER_INSTANCE_BEFORE_KILL;
  static const RemoteProcessInteractionResult FAILED_TO_EXTRACT_PID = ProcessSingleton_RemoteProcessInteractionResult_FAILED_TO_EXTRACT_PID;
  static const RemoteProcessInteractionResult INVALID_LOCK_FILE = ProcessSingleton_RemoteProcessInteractionResult_INVALID_LOCK_FILE;
  static const RemoteProcessInteractionResult ORPHANED_LOCK_FILE = ProcessSingleton_RemoteProcessInteractionResult_ORPHANED_LOCK_FILE;
  static const RemoteProcessInteractionResult USER_REFUSED_TERMINATION = ProcessSingleton_RemoteProcessInteractionResult_USER_REFUSED_TERMINATION;
  static const RemoteProcessInteractionResult TERMINATE_SUCCEEDED = ProcessSingleton_RemoteProcessInteractionResult_TERMINATE_SUCCEEDED;
  static const RemoteHungProcessTerminateReason TERMINATE_REASON_UNSPECIFIED = ProcessSingleton_RemoteHungProcessTerminateReason_TERMINATE_REASON_UNSPECIFIED;
  static const RemoteHungProcessTerminateReason USER_ACCEPTED_TERMINATION = ProcessSingleton_RemoteHungProcessTerminateReason_USER_ACCEPTED_TERMINATION;
  static const RemoteHungProcessTerminateReason NO_VISIBLE_WINDOW_FOUND = ProcessSingleton_RemoteHungProcessTerminateReason_NO_VISIBLE_WINDOW_FOUND;
  static const RemoteHungProcessTerminateReason NOTIFY_ATTEMPTS_EXCEEDED = ProcessSingleton_RemoteHungProcessTerminateReason_NOTIFY_ATTEMPTS_EXCEEDED;
  static const RemoteHungProcessTerminateReason SOCKET_WRITE_FAILED = ProcessSingleton_RemoteHungProcessTerminateReason_SOCKET_WRITE_FAILED;
  static const RemoteHungProcessTerminateReason SOCKET_READ_FAILED = ProcessSingleton_RemoteHungProcessTerminateReason_SOCKET_READ_FAILED;

  using FieldMetadata_RemoteProcessInteractionResult =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult,
      ProcessSingleton>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RemoteProcessInteractionResult kRemoteProcessInteractionResult() { return {}; }
  void set_remote_process_interaction_result(::perfetto::protos::pbzero::ProcessSingleton_RemoteProcessInteractionResult value) {
    static constexpr uint32_t field_id = FieldMetadata_RemoteProcessInteractionResult::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RemoteProcessTerminateReason =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason,
      ProcessSingleton>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RemoteProcessTerminateReason kRemoteProcessTerminateReason() { return {}; }
  void set_remote_process_terminate_reason(::perfetto::protos::pbzero::ProcessSingleton_RemoteHungProcessTerminateReason value) {
    static constexpr uint32_t field_id = FieldMetadata_RemoteProcessTerminateReason::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class EventLatency_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EventLatency_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EventLatency_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EventLatency_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_type() const { return at<1>().valid(); }
  int32_t event_type() const { return at<1>().as_int32(); }
};

class EventLatency : public ::protozero::Message {
 public:
  using Decoder = EventLatency_Decoder;
  enum : int32_t {
    kEventTypeFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.EventLatency"; }

  using EventType = ::perfetto::protos::pbzero::EventLatency_EventType;
  static const EventType EVENT_TYPE_UNSPECIFIED = EventLatency_EventType_EVENT_TYPE_UNSPECIFIED;
  static const EventType MOUSE_PRESSED = EventLatency_EventType_MOUSE_PRESSED;
  static const EventType MOUSE_RELEASED = EventLatency_EventType_MOUSE_RELEASED;
  static const EventType MOUSE_WHEEL = EventLatency_EventType_MOUSE_WHEEL;
  static const EventType KEY_PRESSED = EventLatency_EventType_KEY_PRESSED;
  static const EventType KEY_RELEASED = EventLatency_EventType_KEY_RELEASED;
  static const EventType TOUCH_PRESSED = EventLatency_EventType_TOUCH_PRESSED;
  static const EventType TOUCH_RELEASED = EventLatency_EventType_TOUCH_RELEASED;
  static const EventType TOUCH_MOVED = EventLatency_EventType_TOUCH_MOVED;
  static const EventType GESTURE_SCROLL_BEGIN = EventLatency_EventType_GESTURE_SCROLL_BEGIN;
  static const EventType GESTURE_SCROLL_UPDATE = EventLatency_EventType_GESTURE_SCROLL_UPDATE;
  static const EventType GESTURE_SCROLL_END = EventLatency_EventType_GESTURE_SCROLL_END;
  static const EventType GESTURE_DOUBLE_TAP = EventLatency_EventType_GESTURE_DOUBLE_TAP;
  static const EventType GESTURE_LONG_PRESS = EventLatency_EventType_GESTURE_LONG_PRESS;
  static const EventType GESTURE_LONG_TAP = EventLatency_EventType_GESTURE_LONG_TAP;
  static const EventType GESTURE_SHOW_PRESS = EventLatency_EventType_GESTURE_SHOW_PRESS;
  static const EventType GESTURE_TAP = EventLatency_EventType_GESTURE_TAP;
  static const EventType GESTURE_TAP_CANCEL = EventLatency_EventType_GESTURE_TAP_CANCEL;
  static const EventType GESTURE_TAP_DOWN = EventLatency_EventType_GESTURE_TAP_DOWN;
  static const EventType GESTURE_TAP_UNCONFIRMED = EventLatency_EventType_GESTURE_TAP_UNCONFIRMED;
  static const EventType GESTURE_TWO_FINGER_TAP = EventLatency_EventType_GESTURE_TWO_FINGER_TAP;
  static const EventType FIRST_GESTURE_SCROLL_UPDATE = EventLatency_EventType_FIRST_GESTURE_SCROLL_UPDATE;
  static const EventType MOUSE_DRAGGED = EventLatency_EventType_MOUSE_DRAGGED;
  static const EventType GESTURE_PINCH_BEGIN = EventLatency_EventType_GESTURE_PINCH_BEGIN;
  static const EventType GESTURE_PINCH_END = EventLatency_EventType_GESTURE_PINCH_END;
  static const EventType GESTURE_PINCH_UPDATE = EventLatency_EventType_GESTURE_PINCH_UPDATE;
  static const EventType INERTIAL_GESTURE_SCROLL_UPDATE = EventLatency_EventType_INERTIAL_GESTURE_SCROLL_UPDATE;

  using FieldMetadata_EventType =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::EventLatency_EventType,
      EventLatency>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_EventType kEventType() { return {}; }
  void set_event_type(::perfetto::protos::pbzero::EventLatency_EventType value) {
    static constexpr uint32_t field_id = FieldMetadata_EventType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class RendererMainThreadTaskExecution_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RendererMainThreadTaskExecution_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RendererMainThreadTaskExecution_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RendererMainThreadTaskExecution_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_task_type() const { return at<1>().valid(); }
  int32_t task_type() const { return at<1>().as_int32(); }
  bool has_frame_visible() const { return at<2>().valid(); }
  bool frame_visible() const { return at<2>().as_bool(); }
  bool has_page_visible() const { return at<3>().valid(); }
  bool page_visible() const { return at<3>().as_bool(); }
  bool has_frame_type() const { return at<4>().valid(); }
  int32_t frame_type() const { return at<4>().as_int32(); }
  bool has_is_ad_frame() const { return at<5>().valid(); }
  bool is_ad_frame() const { return at<5>().as_bool(); }
};

class RendererMainThreadTaskExecution : public ::protozero::Message {
 public:
  using Decoder = RendererMainThreadTaskExecution_Decoder;
  enum : int32_t {
    kTaskTypeFieldNumber = 1,
    kFrameVisibleFieldNumber = 2,
    kPageVisibleFieldNumber = 3,
    kFrameTypeFieldNumber = 4,
    kIsAdFrameFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RendererMainThreadTaskExecution"; }

  using TaskType = ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType;
  using FrameType = ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType;
  static const TaskType TASK_TYPE_UNKNOWN = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_UNKNOWN;
  static const TaskType TASK_TYPE_DOM_MANIPULATION = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_DOM_MANIPULATION;
  static const TaskType TASK_TYPE_USER_INTERACTION = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_USER_INTERACTION;
  static const TaskType TASK_TYPE_NETWORKING = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_NETWORKING;
  static const TaskType TASK_TYPE_NETWORKING_CONTROL = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_NETWORKING_CONTROL;
  static const TaskType TASK_TYPE_HISTORY_TRAVERSAL = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_HISTORY_TRAVERSAL;
  static const TaskType TASK_TYPE_EMBED = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_EMBED;
  static const TaskType TASK_TYPE_MEDIA_ELEMENT_EVENT = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MEDIA_ELEMENT_EVENT;
  static const TaskType TASK_TYPE_CANVAS_BLOB_SERIALIZATION = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_CANVAS_BLOB_SERIALIZATION;
  static const TaskType TASK_TYPE_MICROTASK = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MICROTASK;
  static const TaskType TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_HIGH_NESTING = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_HIGH_NESTING;
  static const TaskType TASK_TYPE_REMOTE_EVENT = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_REMOTE_EVENT;
  static const TaskType TASK_TYPE_WEB_SOCKET = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WEB_SOCKET;
  static const TaskType TASK_TYPE_POSTED_MESSAGE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_POSTED_MESSAGE;
  static const TaskType TASK_TYPE_UNSHIPPED_PORT_MESSAGE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_UNSHIPPED_PORT_MESSAGE;
  static const TaskType TASK_TYPE_FILE_READING = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_FILE_READING;
  static const TaskType TASK_TYPE_DATABASE_ACCESS = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_DATABASE_ACCESS;
  static const TaskType TASK_TYPE_PRESENTATION = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_PRESENTATION;
  static const TaskType TASK_TYPE_SENSOR = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_SENSOR;
  static const TaskType TASK_TYPE_PERFORMANCE_TIMELINE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_PERFORMANCE_TIMELINE;
  static const TaskType TASK_TYPE_WEB_GL = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WEB_GL;
  static const TaskType TASK_TYPE_IDLE_TASK = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_IDLE_TASK;
  static const TaskType TASK_TYPE_MISC_PLATFORM_API = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MISC_PLATFORM_API;
  static const TaskType TASK_TYPE_INTERNAL_DEFAULT = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_DEFAULT;
  static const TaskType TASK_TYPE_INTERNAL_LOADING = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_LOADING;
  static const TaskType TASK_TYPE_INTERNAL_TEST = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_TEST;
  static const TaskType TASK_TYPE_INTERNAL_WEB_CRYPTO = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_WEB_CRYPTO;
  static const TaskType TASK_TYPE_INTERNAL_MEDIA = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_MEDIA;
  static const TaskType TASK_TYPE_INTERNAL_MEDIA_REALTIME = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_MEDIA_REALTIME;
  static const TaskType TASK_TYPE_INTERNAL_USER_INTERACTION = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_USER_INTERACTION;
  static const TaskType TASK_TYPE_INTERNAL_INSPECTOR = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_INSPECTOR;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_V8 = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_V8;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_COMPOSITOR = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_COMPOSITOR;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_DEFAULT = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_DEFAULT;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_INPUT = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_INPUT;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IDLE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IDLE;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_CONTROL = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_CONTROL;
  static const TaskType TASK_TYPE_INTERNAL_INTERSECTION_OBSERVER = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_INTERSECTION_OBSERVER;
  static const TaskType TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_DEFAULT = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_DEFAULT;
  static const TaskType TASK_TYPE_WORKER_THREAD_TASK_QUEUE_DEFAULT = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WORKER_THREAD_TASK_QUEUE_DEFAULT;
  static const TaskType TASK_TYPE_WORKER_THREAD_TASK_QUEUE_V8 = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WORKER_THREAD_TASK_QUEUE_V8;
  static const TaskType TASK_TYPE_WORKER_THREAD_TASK_QUEUE_COMPOSITOR = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WORKER_THREAD_TASK_QUEUE_COMPOSITOR;
  static const TaskType TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_INPUT = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_COMPOSITOR_THREAD_TASK_QUEUE_INPUT;
  static const TaskType TASK_TYPE_NETWORKING_WITH_URL_LOADER_ANNOTATION = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_NETWORKING_WITH_URL_LOADER_ANNOTATION;
  static const TaskType TASK_TYPE_WORKER_ANIMATION = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WORKER_ANIMATION;
  static const TaskType TASK_TYPE_INTERNAL_TRANSLATION = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_TRANSLATION;
  static const TaskType TASK_TYPE_FONT_LOADING = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_FONT_LOADING;
  static const TaskType TASK_TYPE_APPLICATION_LIFECYCLE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_APPLICATION_LIFECYCLE;
  static const TaskType TASK_TYPE_BACKGROUND_FETCH = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_BACKGROUND_FETCH;
  static const TaskType TASK_TYPE_PERMISSION = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_PERMISSION;
  static const TaskType TASK_TYPE_SERVICE_WORKER_CLIENT_MESSAGE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_SERVICE_WORKER_CLIENT_MESSAGE;
  static const TaskType TASK_TYPE_INTERNAL_CONTENT_CAPTURE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_CONTENT_CAPTURE;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_MEMORY_PURGE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_MEMORY_PURGE;
  static const TaskType TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED;
  static const TaskType TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED_UNFREEZABLE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_NAVIGATION_ASSOCIATED_UNFREEZABLE;
  static const TaskType TASK_TYPE_INTERNAL_CONTINUE_SCRIPT_LOADING = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_CONTINUE_SCRIPT_LOADING;
  static const TaskType TASK_TYPE_WEB_LOCKS = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WEB_LOCKS;
  static const TaskType TASK_TYPE_WEB_SCHEDULING_POSTED_TASK = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WEB_SCHEDULING_POSTED_TASK;
  static const TaskType TASK_TYPE_INTERNAL_FRAME_LIFE_CYCLE_CONTROL = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_FRAME_LIFE_CYCLE_CONTROL;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_NON_WAKING = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_NON_WAKING;
  static const TaskType TASK_TYPE_INTERNAL_FIND_IN_PAGE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_FIND_IN_PAGE;
  static const TaskType TASK_TYPE_INTERNAL_HIGH_PRIORITY_LOCAL_FRAME = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_HIGH_PRIORITY_LOCAL_FRAME;
  static const TaskType TASK_TYPE_JAVASCRIPT_TIMER_IMMEDIATE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_JAVASCRIPT_TIMER_IMMEDIATE;
  static const TaskType TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_LOW_NESTING = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_JAVASCRIPT_TIMER_DELAYED_LOW_NESTING;
  static const TaskType TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IPC_TRACKING = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_MAIN_THREAD_TASK_QUEUE_IPC_TRACKING;
  static const TaskType TASK_TYPE_NETWORKING_UNFREEZABLE = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_NETWORKING_UNFREEZABLE;
  static const TaskType TASK_TYPE_WAKE_LOCK = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WAKE_LOCK;
  static const TaskType TASK_TYPE_INTERNAL_INPUT_BLOCKING = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_INPUT_BLOCKING;
  static const TaskType TASK_TYPE_WEB_GPU = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_WEB_GPU;
  static const TaskType TASK_TYPE_INTERNAL_POST_MESSAGE_FORWARDING = RendererMainThreadTaskExecution_TaskType_TASK_TYPE_INTERNAL_POST_MESSAGE_FORWARDING;
  static const FrameType FRAME_TYPE_UNSPECIFIED = RendererMainThreadTaskExecution_FrameType_FRAME_TYPE_UNSPECIFIED;
  static const FrameType FRAME_TYPE_MAIN_FRAME = RendererMainThreadTaskExecution_FrameType_FRAME_TYPE_MAIN_FRAME;
  static const FrameType FRAME_TYPE_SAME_ORIGIN_SUBFRAME = RendererMainThreadTaskExecution_FrameType_FRAME_TYPE_SAME_ORIGIN_SUBFRAME;
  static const FrameType FRAME_TYPE_CROSS_ORIGIN_SUBFRAME = RendererMainThreadTaskExecution_FrameType_FRAME_TYPE_CROSS_ORIGIN_SUBFRAME;

  using FieldMetadata_TaskType =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType,
      RendererMainThreadTaskExecution>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TaskType kTaskType() { return {}; }
  void set_task_type(::perfetto::protos::pbzero::RendererMainThreadTaskExecution_TaskType value) {
    static constexpr uint32_t field_id = FieldMetadata_TaskType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrameVisible =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RendererMainThreadTaskExecution>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameVisible kFrameVisible() { return {}; }
  void set_frame_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameVisible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PageVisible =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RendererMainThreadTaskExecution>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PageVisible kPageVisible() { return {}; }
  void set_page_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_PageVisible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrameType =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType,
      RendererMainThreadTaskExecution>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameType kFrameType() { return {}; }
  void set_frame_type(::perfetto::protos::pbzero::RendererMainThreadTaskExecution_FrameType value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsAdFrame =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RendererMainThreadTaskExecution>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsAdFrame kIsAdFrame() { return {}; }
  void set_is_ad_frame(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsAdFrame::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class BackForwardCacheCanStoreDocumentResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BackForwardCacheCanStoreDocumentResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BackForwardCacheCanStoreDocumentResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BackForwardCacheCanStoreDocumentResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_back_forward_cache_not_restored_reason() const { return at<1>().valid(); }
  int32_t back_forward_cache_not_restored_reason() const { return at<1>().as_int32(); }
};

class BackForwardCacheCanStoreDocumentResult : public ::protozero::Message {
 public:
  using Decoder = BackForwardCacheCanStoreDocumentResult_Decoder;
  enum : int32_t {
    kBackForwardCacheNotRestoredReasonFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BackForwardCacheCanStoreDocumentResult"; }

  using BackForwardCacheNotRestoredReason = ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason;
  static const BackForwardCacheNotRestoredReason NOT_MAIN_FRAME = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NOT_MAIN_FRAME;
  static const BackForwardCacheNotRestoredReason BACK_FORWARD_CACHE_DISABLED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BACK_FORWARD_CACHE_DISABLED;
  static const BackForwardCacheNotRestoredReason RELATED_ACTIVE_CONTENTS_EXIST = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_RELATED_ACTIVE_CONTENTS_EXIST;
  static const BackForwardCacheNotRestoredReason HTTP_STATUS_NOT_OK = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_HTTP_STATUS_NOT_OK;
  static const BackForwardCacheNotRestoredReason SCHEME_NOT_HTTP_OR_HTTPS = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SCHEME_NOT_HTTP_OR_HTTPS;
  static const BackForwardCacheNotRestoredReason LOADING = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_LOADING;
  static const BackForwardCacheNotRestoredReason WAS_GRANTED_MEDIA_ACCESS = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_WAS_GRANTED_MEDIA_ACCESS;
  static const BackForwardCacheNotRestoredReason BLOCKLISTED_FEATURES = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BLOCKLISTED_FEATURES;
  static const BackForwardCacheNotRestoredReason DISABLE_FOR_RENDER_FRAME_HOST_CALLED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_DISABLE_FOR_RENDER_FRAME_HOST_CALLED;
  static const BackForwardCacheNotRestoredReason DOMAIN_NOT_ALLOWED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_DOMAIN_NOT_ALLOWED;
  static const BackForwardCacheNotRestoredReason HTTP_METHOD_NOT_GET = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_HTTP_METHOD_NOT_GET;
  static const BackForwardCacheNotRestoredReason SUBFRAME_IS_NAVIGATING = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SUBFRAME_IS_NAVIGATING;
  static const BackForwardCacheNotRestoredReason TIMEOUT = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_TIMEOUT;
  static const BackForwardCacheNotRestoredReason CACHE_LIMIT = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CACHE_LIMIT;
  static const BackForwardCacheNotRestoredReason JAVASCRIPT_EXECUTION = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_JAVASCRIPT_EXECUTION;
  static const BackForwardCacheNotRestoredReason RENDERER_PROCESS_KILLED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_RENDERER_PROCESS_KILLED;
  static const BackForwardCacheNotRestoredReason RENDERER_PROCESS_CRASHED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_RENDERER_PROCESS_CRASHED;
  static const BackForwardCacheNotRestoredReason GRANTED_MEDIA_STREAM_ACCESS = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_GRANTED_MEDIA_STREAM_ACCESS;
  static const BackForwardCacheNotRestoredReason SCHEDULER_TRACKED_FEATURE_USED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SCHEDULER_TRACKED_FEATURE_USED;
  static const BackForwardCacheNotRestoredReason CONFLICTING_BROWSING_INSTANCE = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CONFLICTING_BROWSING_INSTANCE;
  static const BackForwardCacheNotRestoredReason CACHE_FLUSHED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CACHE_FLUSHED;
  static const BackForwardCacheNotRestoredReason SERVICE_WORKER_VERSION_ACTIVATION = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SERVICE_WORKER_VERSION_ACTIVATION;
  static const BackForwardCacheNotRestoredReason SESSION_RESTORED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SESSION_RESTORED;
  static const BackForwardCacheNotRestoredReason UNKNOWN = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_UNKNOWN;
  static const BackForwardCacheNotRestoredReason SERVICE_WORKER_POST_MESSAGE = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SERVICE_WORKER_POST_MESSAGE;
  static const BackForwardCacheNotRestoredReason ENTERED_BACK_FORWARD_CACHE_BEFORE_SERVICE_WORKER_HOST_ADDED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_ENTERED_BACK_FORWARD_CACHE_BEFORE_SERVICE_WORKER_HOST_ADDED;
  static const BackForwardCacheNotRestoredReason NOT_MOST_RECENT_NAVIGATION_ENTRY = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NOT_MOST_RECENT_NAVIGATION_ENTRY;
  static const BackForwardCacheNotRestoredReason SERVICE_WORKER_CLAIM = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SERVICE_WORKER_CLAIM;
  static const BackForwardCacheNotRestoredReason IGNORE_EVENT_AND_EVICT = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_IGNORE_EVENT_AND_EVICT;
  static const BackForwardCacheNotRestoredReason HAVE_INNER_CONTENTS = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_HAVE_INNER_CONTENTS;
  static const BackForwardCacheNotRestoredReason TIMEOUT_PUTTING_IN_CACHE = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_TIMEOUT_PUTTING_IN_CACHE;
  static const BackForwardCacheNotRestoredReason BACK_FORWARD_CACHE_DISABLED_BY_LOW_MEMORY = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BACK_FORWARD_CACHE_DISABLED_BY_LOW_MEMORY;
  static const BackForwardCacheNotRestoredReason BACK_FORWARD_CACHE_DISABLED_BY_COMMAND_LINE = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BACK_FORWARD_CACHE_DISABLED_BY_COMMAND_LINE;
  static const BackForwardCacheNotRestoredReason NETWORK_REQUEST_REDIRECTED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NETWORK_REQUEST_REDIRECTED;
  static const BackForwardCacheNotRestoredReason NETWORK_REQUEST_TIMEOUT = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NETWORK_REQUEST_TIMEOUT;
  static const BackForwardCacheNotRestoredReason NETWORK_EXCEEDS_BUFFER_LIMIT = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NETWORK_EXCEEDS_BUFFER_LIMIT;
  static const BackForwardCacheNotRestoredReason NAVIGATION_CANCELLED_WHILE_RESTORING = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NAVIGATION_CANCELLED_WHILE_RESTORING;
  static const BackForwardCacheNotRestoredReason BACK_FORWARD_CACHE_DISABLED_FOR_PRERENDER = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BACK_FORWARD_CACHE_DISABLED_FOR_PRERENDER;
  static const BackForwardCacheNotRestoredReason USER_AGENT_OVERRIDE_DIFFERS = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_USER_AGENT_OVERRIDE_DIFFERS;
  static const BackForwardCacheNotRestoredReason NETWORK_REQUEST_DATAPIPE_DRAINED_AS_BYTES_CONSUMER = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NETWORK_REQUEST_DATAPIPE_DRAINED_AS_BYTES_CONSUMER;
  static const BackForwardCacheNotRestoredReason FOREGROUND_CACHE_LIMIT = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_FOREGROUND_CACHE_LIMIT;
  static const BackForwardCacheNotRestoredReason BROWSING_INSTANCE_NOT_SWAPPED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BROWSING_INSTANCE_NOT_SWAPPED;
  static const BackForwardCacheNotRestoredReason BACK_FORWARD_CACHE_DISABLED_FOR_DELEGATE = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_BACK_FORWARD_CACHE_DISABLED_FOR_DELEGATE;
  static const BackForwardCacheNotRestoredReason OPT_IN_UNLOAD_HEADER_NOT_PRESENT = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_OPT_IN_UNLOAD_HEADER_NOT_PRESENT;
  static const BackForwardCacheNotRestoredReason UNLOAD_HANDLER_EXISTS_IN_MAIN_FRAME = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_UNLOAD_HANDLER_EXISTS_IN_MAIN_FRAME;
  static const BackForwardCacheNotRestoredReason UNLOAD_HANDLER_EXISTS_IN_SUBFRAME = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_UNLOAD_HANDLER_EXISTS_IN_SUBFRAME;
  static const BackForwardCacheNotRestoredReason SERVICE_WORKER_UNREGISTRATION = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_SERVICE_WORKER_UNREGISTRATION;
  static const BackForwardCacheNotRestoredReason CACHE_CONTROL_NO_STORE = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CACHE_CONTROL_NO_STORE;
  static const BackForwardCacheNotRestoredReason CACHE_CONTROL_NO_STORE_COOKIE_MODIFIED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CACHE_CONTROL_NO_STORE_COOKIE_MODIFIED;
  static const BackForwardCacheNotRestoredReason CACHE_CONTROL_NO_STORE_HTTP_ONLY_COOKIE_MODIFIED = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_CACHE_CONTROL_NO_STORE_HTTP_ONLY_COOKIE_MODIFIED;
  static const BackForwardCacheNotRestoredReason NO_RESPONSE_HEAD = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_NO_RESPONSE_HEAD;
  static const BackForwardCacheNotRestoredReason ACTIVATION_NAVIGATION_DISALLOWED_FOR_BUG_1234857 = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_ACTIVATION_NAVIGATION_DISALLOWED_FOR_BUG_1234857;
  static const BackForwardCacheNotRestoredReason ERROR_DOCUMENT = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_ERROR_DOCUMENT;
  static const BackForwardCacheNotRestoredReason FENCED_FRAMES_EMBEDDER = BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason_FENCED_FRAMES_EMBEDDER;

  using FieldMetadata_BackForwardCacheNotRestoredReason =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason,
      BackForwardCacheCanStoreDocumentResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BackForwardCacheNotRestoredReason kBackForwardCacheNotRestoredReason() { return {}; }
  void set_back_forward_cache_not_restored_reason(::perfetto::protos::pbzero::BackForwardCacheCanStoreDocumentResult_BackForwardCacheNotRestoredReason value) {
    static constexpr uint32_t field_id = FieldMetadata_BackForwardCacheNotRestoredReason::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class ChromeThreadPoolTask_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeThreadPoolTask_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeThreadPoolTask_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeThreadPoolTask_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_task_priority() const { return at<1>().valid(); }
  int32_t task_priority() const { return at<1>().as_int32(); }
  bool has_execution_mode() const { return at<2>().valid(); }
  int32_t execution_mode() const { return at<2>().as_int32(); }
  bool has_sequence_token() const { return at<3>().valid(); }
  int64_t sequence_token() const { return at<3>().as_int64(); }
  bool has_shutdown_behavior() const { return at<4>().valid(); }
  int32_t shutdown_behavior() const { return at<4>().as_int32(); }
};

class ChromeThreadPoolTask : public ::protozero::Message {
 public:
  using Decoder = ChromeThreadPoolTask_Decoder;
  enum : int32_t {
    kTaskPriorityFieldNumber = 1,
    kExecutionModeFieldNumber = 2,
    kSequenceTokenFieldNumber = 3,
    kShutdownBehaviorFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeThreadPoolTask"; }

  using Priority = ::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority;
  using ExecutionMode = ::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode;
  using ShutdownBehavior = ::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior;
  static const Priority PRIORITY_UNSPECIFIED = ChromeThreadPoolTask_Priority_PRIORITY_UNSPECIFIED;
  static const Priority PRIORITY_BEST_EFFORT = ChromeThreadPoolTask_Priority_PRIORITY_BEST_EFFORT;
  static const Priority PRIORITY_USER_VISIBLE = ChromeThreadPoolTask_Priority_PRIORITY_USER_VISIBLE;
  static const Priority PRIORITY_USER_BLOCKING = ChromeThreadPoolTask_Priority_PRIORITY_USER_BLOCKING;
  static const ExecutionMode EXECTUION_MODE_UNSPECIFIED = ChromeThreadPoolTask_ExecutionMode_EXECTUION_MODE_UNSPECIFIED;
  static const ExecutionMode EXECUTION_MODE_PARALLEL = ChromeThreadPoolTask_ExecutionMode_EXECUTION_MODE_PARALLEL;
  static const ExecutionMode EXECUTION_MODE_SEQUENCED = ChromeThreadPoolTask_ExecutionMode_EXECUTION_MODE_SEQUENCED;
  static const ExecutionMode EXECUTION_MODE_SINGLE_THREAD = ChromeThreadPoolTask_ExecutionMode_EXECUTION_MODE_SINGLE_THREAD;
  static const ExecutionMode EXECUTION_MODE_JOB = ChromeThreadPoolTask_ExecutionMode_EXECUTION_MODE_JOB;
  static const ShutdownBehavior SHUTDOWN_BEHAVIOR_UNSPECIFIED = ChromeThreadPoolTask_ShutdownBehavior_SHUTDOWN_BEHAVIOR_UNSPECIFIED;
  static const ShutdownBehavior SHUTDOWN_BEHAVIOR_CONTINUE_ON_SHUTDOWN = ChromeThreadPoolTask_ShutdownBehavior_SHUTDOWN_BEHAVIOR_CONTINUE_ON_SHUTDOWN;
  static const ShutdownBehavior SHUTDOWN_BEHAVIOR_SKIP_ON_SHUTDOWN = ChromeThreadPoolTask_ShutdownBehavior_SHUTDOWN_BEHAVIOR_SKIP_ON_SHUTDOWN;
  static const ShutdownBehavior SHUTDOWN_BEHAVIOR_BLOCK_SHUTDOWN = ChromeThreadPoolTask_ShutdownBehavior_SHUTDOWN_BEHAVIOR_BLOCK_SHUTDOWN;

  using FieldMetadata_TaskPriority =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority,
      ChromeThreadPoolTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TaskPriority kTaskPriority() { return {}; }
  void set_task_priority(::perfetto::protos::pbzero::ChromeThreadPoolTask_Priority value) {
    static constexpr uint32_t field_id = FieldMetadata_TaskPriority::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ExecutionMode =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode,
      ChromeThreadPoolTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ExecutionMode kExecutionMode() { return {}; }
  void set_execution_mode(::perfetto::protos::pbzero::ChromeThreadPoolTask_ExecutionMode value) {
    static constexpr uint32_t field_id = FieldMetadata_ExecutionMode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SequenceToken =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      ChromeThreadPoolTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SequenceToken kSequenceToken() { return {}; }
  void set_sequence_token(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SequenceToken::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShutdownBehavior =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior,
      ChromeThreadPoolTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ShutdownBehavior kShutdownBehavior() { return {}; }
  void set_shutdown_behavior(::perfetto::protos::pbzero::ChromeThreadPoolTask_ShutdownBehavior value) {
    static constexpr uint32_t field_id = FieldMetadata_ShutdownBehavior::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class RenderFrameHost_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RenderFrameHost_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderFrameHost_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderFrameHost_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_process() const { return at<1>().valid(); }
  ::protozero::ConstBytes process() const { return at<1>().as_bytes(); }
  bool has_render_frame_host_id() const { return at<2>().valid(); }
  ::protozero::ConstBytes render_frame_host_id() const { return at<2>().as_bytes(); }
  bool has_lifecycle_state() const { return at<3>().valid(); }
  int32_t lifecycle_state() const { return at<3>().as_int32(); }
  bool has_origin() const { return at<4>().valid(); }
  ::protozero::ConstChars origin() const { return at<4>().as_string(); }
  bool has_url() const { return at<5>().valid(); }
  ::protozero::ConstChars url() const { return at<5>().as_string(); }
  bool has_frame_tree_node_id() const { return at<6>().valid(); }
  uint64_t frame_tree_node_id() const { return at<6>().as_uint64(); }
  bool has_site_instance() const { return at<7>().valid(); }
  ::protozero::ConstBytes site_instance() const { return at<7>().as_bytes(); }
  bool has_parent() const { return at<8>().valid(); }
  ::protozero::ConstBytes parent() const { return at<8>().as_bytes(); }
  bool has_outer_document() const { return at<9>().valid(); }
  ::protozero::ConstBytes outer_document() const { return at<9>().as_bytes(); }
  bool has_embedder() const { return at<10>().valid(); }
  ::protozero::ConstBytes embedder() const { return at<10>().as_bytes(); }
  bool has_browsing_context_state() const { return at<11>().valid(); }
  ::protozero::ConstBytes browsing_context_state() const { return at<11>().as_bytes(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class RenderFrameHost : public ::protozero::Message {
 public:
  using Decoder = RenderFrameHost_Decoder;
  enum : int32_t {
    kProcessFieldNumber = 1,
    kRenderFrameHostIdFieldNumber = 2,
    kLifecycleStateFieldNumber = 3,
    kOriginFieldNumber = 4,
    kUrlFieldNumber = 5,
    kFrameTreeNodeIdFieldNumber = 6,
    kSiteInstanceFieldNumber = 7,
    kParentFieldNumber = 8,
    kOuterDocumentFieldNumber = 9,
    kEmbedderFieldNumber = 10,
    kBrowsingContextStateFieldNumber = 11,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderFrameHost"; }

  using LifecycleState = ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState;
  static const LifecycleState UNSPECIFIED = RenderFrameHost_LifecycleState_UNSPECIFIED;
  static const LifecycleState SPECULATIVE = RenderFrameHost_LifecycleState_SPECULATIVE;
  static const LifecycleState PENDING_COMMIT = RenderFrameHost_LifecycleState_PENDING_COMMIT;
  static const LifecycleState PRERENDERING = RenderFrameHost_LifecycleState_PRERENDERING;
  static const LifecycleState ACTIVE = RenderFrameHost_LifecycleState_ACTIVE;
  static const LifecycleState IN_BACK_FORWARD_CACHE = RenderFrameHost_LifecycleState_IN_BACK_FORWARD_CACHE;
  static const LifecycleState RUNNING_UNLOAD_HANDLERS = RenderFrameHost_LifecycleState_RUNNING_UNLOAD_HANDLERS;
  static const LifecycleState READY_TO_BE_DELETED = RenderFrameHost_LifecycleState_READY_TO_BE_DELETED;

  using FieldMetadata_Process =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHost,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Process kProcess() { return {}; }
  template <typename T = RenderProcessHost> T* set_process() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_RenderFrameHostId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      GlobalRenderFrameHostId,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderFrameHostId kRenderFrameHostId() { return {}; }
  template <typename T = GlobalRenderFrameHostId> T* set_render_frame_host_id() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_LifecycleState =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::RenderFrameHost_LifecycleState,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LifecycleState kLifecycleState() { return {}; }
  void set_lifecycle_state(::perfetto::protos::pbzero::RenderFrameHost_LifecycleState value) {
    static constexpr uint32_t field_id = FieldMetadata_LifecycleState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Origin =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Origin kOrigin() { return {}; }
  void set_origin(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Origin::kFieldId, data, size);
  }
  void set_origin(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Origin::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Url =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Url kUrl() { return {}; }
  void set_url(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Url::kFieldId, data, size);
  }
  void set_url(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Url::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrameTreeNodeId =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNodeId kFrameTreeNodeId() { return {}; }
  void set_frame_tree_node_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameTreeNodeId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SiteInstance =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SiteInstance,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstance kSiteInstance() { return {}; }
  template <typename T = SiteInstance> T* set_site_instance() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_Parent =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Parent kParent() { return {}; }
  template <typename T = RenderFrameHost> T* set_parent() {
    return BeginNestedMessage<T>(8);
  }


  using FieldMetadata_OuterDocument =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_OuterDocument kOuterDocument() { return {}; }
  template <typename T = RenderFrameHost> T* set_outer_document() {
    return BeginNestedMessage<T>(9);
  }


  using FieldMetadata_Embedder =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Embedder kEmbedder() { return {}; }
  template <typename T = RenderFrameHost> T* set_embedder() {
    return BeginNestedMessage<T>(10);
  }


  using FieldMetadata_BrowsingContextState =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BrowsingContextState,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BrowsingContextState kBrowsingContextState() { return {}; }
  template <typename T = BrowsingContextState> T* set_browsing_context_state() {
    return BeginNestedMessage<T>(11);
  }


  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      RenderFrameHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class BrowsingContextState_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  BrowsingContextState_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BrowsingContextState_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BrowsingContextState_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_browsing_instance_id() const { return at<1>().valid(); }
  int32_t browsing_instance_id() const { return at<1>().as_int32(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class BrowsingContextState : public ::protozero::Message {
 public:
  using Decoder = BrowsingContextState_Decoder;
  enum : int32_t {
    kBrowsingInstanceIdFieldNumber = 1,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BrowsingContextState"; }


  using FieldMetadata_BrowsingInstanceId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      BrowsingContextState>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BrowsingInstanceId kBrowsingInstanceId() { return {}; }
  void set_browsing_instance_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BrowsingInstanceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      BrowsingContextState>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class GlobalRenderFrameHostId_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GlobalRenderFrameHostId_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GlobalRenderFrameHostId_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GlobalRenderFrameHostId_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_routing_id() const { return at<1>().valid(); }
  int32_t routing_id() const { return at<1>().as_int32(); }
  bool has_process_id() const { return at<2>().valid(); }
  int32_t process_id() const { return at<2>().as_int32(); }
};

class GlobalRenderFrameHostId : public ::protozero::Message {
 public:
  using Decoder = GlobalRenderFrameHostId_Decoder;
  enum : int32_t {
    kRoutingIdFieldNumber = 1,
    kProcessIdFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.GlobalRenderFrameHostId"; }


  using FieldMetadata_RoutingId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      GlobalRenderFrameHostId>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RoutingId kRoutingId() { return {}; }
  void set_routing_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RoutingId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ProcessId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      GlobalRenderFrameHostId>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProcessId kProcessId() { return {}; }
  void set_process_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ProcessId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class SendBeginMainFrameToCommitBreakdown_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/12, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SendBeginMainFrameToCommitBreakdown_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SendBeginMainFrameToCommitBreakdown_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SendBeginMainFrameToCommitBreakdown_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_handle_input_events_us() const { return at<1>().valid(); }
  uint64_t handle_input_events_us() const { return at<1>().as_uint64(); }
  bool has_animate_us() const { return at<2>().valid(); }
  uint64_t animate_us() const { return at<2>().as_uint64(); }
  bool has_style_update_us() const { return at<3>().valid(); }
  uint64_t style_update_us() const { return at<3>().as_uint64(); }
  bool has_layout_update_us() const { return at<4>().valid(); }
  uint64_t layout_update_us() const { return at<4>().as_uint64(); }
  bool has_accessibility_update_us() const { return at<12>().valid(); }
  uint64_t accessibility_update_us() const { return at<12>().as_uint64(); }
  bool has_prepaint_us() const { return at<5>().valid(); }
  uint64_t prepaint_us() const { return at<5>().as_uint64(); }
  bool has_compositing_inputs_us() const { return at<6>().valid(); }
  uint64_t compositing_inputs_us() const { return at<6>().as_uint64(); }
  bool has_compositing_assignments_us() const { return at<7>().valid(); }
  uint64_t compositing_assignments_us() const { return at<7>().as_uint64(); }
  bool has_paint_us() const { return at<8>().valid(); }
  uint64_t paint_us() const { return at<8>().as_uint64(); }
  bool has_composite_commit_us() const { return at<9>().valid(); }
  uint64_t composite_commit_us() const { return at<9>().as_uint64(); }
  bool has_update_layers_us() const { return at<10>().valid(); }
  uint64_t update_layers_us() const { return at<10>().as_uint64(); }
  bool has_begin_main_sent_to_started_us() const { return at<11>().valid(); }
  uint64_t begin_main_sent_to_started_us() const { return at<11>().as_uint64(); }
};

class SendBeginMainFrameToCommitBreakdown : public ::protozero::Message {
 public:
  using Decoder = SendBeginMainFrameToCommitBreakdown_Decoder;
  enum : int32_t {
    kHandleInputEventsUsFieldNumber = 1,
    kAnimateUsFieldNumber = 2,
    kStyleUpdateUsFieldNumber = 3,
    kLayoutUpdateUsFieldNumber = 4,
    kAccessibilityUpdateUsFieldNumber = 12,
    kPrepaintUsFieldNumber = 5,
    kCompositingInputsUsFieldNumber = 6,
    kCompositingAssignmentsUsFieldNumber = 7,
    kPaintUsFieldNumber = 8,
    kCompositeCommitUsFieldNumber = 9,
    kUpdateLayersUsFieldNumber = 10,
    kBeginMainSentToStartedUsFieldNumber = 11,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SendBeginMainFrameToCommitBreakdown"; }


  using FieldMetadata_HandleInputEventsUs =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HandleInputEventsUs kHandleInputEventsUs() { return {}; }
  void set_handle_input_events_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_HandleInputEventsUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AnimateUs =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AnimateUs kAnimateUs() { return {}; }
  void set_animate_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_AnimateUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StyleUpdateUs =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_StyleUpdateUs kStyleUpdateUs() { return {}; }
  void set_style_update_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_StyleUpdateUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LayoutUpdateUs =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LayoutUpdateUs kLayoutUpdateUs() { return {}; }
  void set_layout_update_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LayoutUpdateUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AccessibilityUpdateUs =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AccessibilityUpdateUs kAccessibilityUpdateUs() { return {}; }
  void set_accessibility_update_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_AccessibilityUpdateUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PrepaintUs =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PrepaintUs kPrepaintUs() { return {}; }
  void set_prepaint_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_PrepaintUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CompositingInputsUs =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CompositingInputsUs kCompositingInputsUs() { return {}; }
  void set_compositing_inputs_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CompositingInputsUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CompositingAssignmentsUs =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CompositingAssignmentsUs kCompositingAssignmentsUs() { return {}; }
  void set_compositing_assignments_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CompositingAssignmentsUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PaintUs =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PaintUs kPaintUs() { return {}; }
  void set_paint_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_PaintUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CompositeCommitUs =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CompositeCommitUs kCompositeCommitUs() { return {}; }
  void set_composite_commit_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CompositeCommitUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_UpdateLayersUs =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_UpdateLayersUs kUpdateLayersUs() { return {}; }
  void set_update_layers_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_UpdateLayersUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_BeginMainSentToStartedUs =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SendBeginMainFrameToCommitBreakdown>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BeginMainSentToStartedUs kBeginMainSentToStartedUs() { return {}; }
  void set_begin_main_sent_to_started_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BeginMainSentToStartedUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class ChromeSamplingProfilerSampleCollected_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeSamplingProfilerSampleCollected_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeSamplingProfilerSampleCollected_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeSamplingProfilerSampleCollected_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_frame_count() const { return at<1>().valid(); }
  int32_t frame_count() const { return at<1>().as_int32(); }
  bool has_write_status() const { return at<2>().valid(); }
  int32_t write_status() const { return at<2>().as_int32(); }
  bool has_sampled_thread_id() const { return at<3>().valid(); }
  int32_t sampled_thread_id() const { return at<3>().as_int32(); }
};

class ChromeSamplingProfilerSampleCollected : public ::protozero::Message {
 public:
  using Decoder = ChromeSamplingProfilerSampleCollected_Decoder;
  enum : int32_t {
    kFrameCountFieldNumber = 1,
    kWriteStatusFieldNumber = 2,
    kSampledThreadIdFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeSamplingProfilerSampleCollected"; }

  using WriteStatus = ::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus;
  static const WriteStatus WRITE_STATUS_NONE = ChromeSamplingProfilerSampleCollected_WriteStatus_WRITE_STATUS_NONE;
  static const WriteStatus WRITE_STATUS_BUFFERING_SAMPLE = ChromeSamplingProfilerSampleCollected_WriteStatus_WRITE_STATUS_BUFFERING_SAMPLE;
  static const WriteStatus WRITE_STATUS_WRITING_BUFFERED = ChromeSamplingProfilerSampleCollected_WriteStatus_WRITE_STATUS_WRITING_BUFFERED;
  static const WriteStatus WRITE_STATUS_WRITING_TO_TRACE = ChromeSamplingProfilerSampleCollected_WriteStatus_WRITE_STATUS_WRITING_TO_TRACE;

  using FieldMetadata_FrameCount =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ChromeSamplingProfilerSampleCollected>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameCount kFrameCount() { return {}; }
  void set_frame_count(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WriteStatus =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus,
      ChromeSamplingProfilerSampleCollected>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WriteStatus kWriteStatus() { return {}; }
  void set_write_status(::perfetto::protos::pbzero::ChromeSamplingProfilerSampleCollected_WriteStatus value) {
    static constexpr uint32_t field_id = FieldMetadata_WriteStatus::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SampledThreadId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ChromeSamplingProfilerSampleCollected>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SampledThreadId kSampledThreadId() { return {}; }
  void set_sampled_thread_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SampledThreadId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class ParkableStringUnpark_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ParkableStringUnpark_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ParkableStringUnpark_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ParkableStringUnpark_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_size_bytes() const { return at<1>().valid(); }
  int32_t size_bytes() const { return at<1>().as_int32(); }
  bool has_time_since_last_disk_write_sec() const { return at<2>().valid(); }
  int32_t time_since_last_disk_write_sec() const { return at<2>().as_int32(); }
};

class ParkableStringUnpark : public ::protozero::Message {
 public:
  using Decoder = ParkableStringUnpark_Decoder;
  enum : int32_t {
    kSizeBytesFieldNumber = 1,
    kTimeSinceLastDiskWriteSecFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ParkableStringUnpark"; }


  using FieldMetadata_SizeBytes =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ParkableStringUnpark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SizeBytes kSizeBytes() { return {}; }
  void set_size_bytes(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SizeBytes::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TimeSinceLastDiskWriteSec =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ParkableStringUnpark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TimeSinceLastDiskWriteSec kTimeSinceLastDiskWriteSec() { return {}; }
  void set_time_since_last_disk_write_sec(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TimeSinceLastDiskWriteSec::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class ParkableStringCompressInBackground_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ParkableStringCompressInBackground_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ParkableStringCompressInBackground_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ParkableStringCompressInBackground_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_size_bytes() const { return at<1>().valid(); }
  int32_t size_bytes() const { return at<1>().as_int32(); }
};

class ParkableStringCompressInBackground : public ::protozero::Message {
 public:
  using Decoder = ParkableStringCompressInBackground_Decoder;
  enum : int32_t {
    kSizeBytesFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ParkableStringCompressInBackground"; }


  using FieldMetadata_SizeBytes =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ParkableStringCompressInBackground>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SizeBytes kSizeBytes() { return {}; }
  void set_size_bytes(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SizeBytes::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class AndroidViewDump_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidViewDump_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidViewDump_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidViewDump_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_activity() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> activity() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class AndroidViewDump : public ::protozero::Message {
 public:
  using Decoder = AndroidViewDump_Decoder;
  enum : int32_t {
    kActivityFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.AndroidViewDump"; }


  using FieldMetadata_Activity =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AndroidActivity,
      AndroidViewDump>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Activity kActivity() { return {}; }
  template <typename T = AndroidActivity> T* add_activity() {
    return BeginNestedMessage<T>(1);
  }

};

class AndroidActivity_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidActivity_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidActivity_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidActivity_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_view() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> view() const { return GetRepeated<::protozero::ConstBytes>(2); }
};

class AndroidActivity : public ::protozero::Message {
 public:
  using Decoder = AndroidActivity_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kViewFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.AndroidActivity"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      AndroidActivity>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Name kName() { return {}; }
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_View =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AndroidView,
      AndroidActivity>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_View kView() { return {}; }
  template <typename T = AndroidView> T* add_view() {
    return BeginNestedMessage<T>(2);
  }

};

class AndroidView_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AndroidView_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidView_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidView_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  int32_t id() const { return at<1>().as_int32(); }
  bool has_parent_id() const { return at<2>().valid(); }
  int32_t parent_id() const { return at<2>().as_int32(); }
  bool has_is_shown() const { return at<3>().valid(); }
  bool is_shown() const { return at<3>().as_bool(); }
  bool has_is_dirty() const { return at<4>().valid(); }
  bool is_dirty() const { return at<4>().as_bool(); }
  bool has_class_name() const { return at<5>().valid(); }
  ::protozero::ConstChars class_name() const { return at<5>().as_string(); }
  bool has_resource_name() const { return at<6>().valid(); }
  ::protozero::ConstChars resource_name() const { return at<6>().as_string(); }
};

class AndroidView : public ::protozero::Message {
 public:
  using Decoder = AndroidView_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kParentIdFieldNumber = 2,
    kIsShownFieldNumber = 3,
    kIsDirtyFieldNumber = 4,
    kClassNameFieldNumber = 5,
    kResourceNameFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.AndroidView"; }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Id kId() { return {}; }
  void set_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ParentId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ParentId kParentId() { return {}; }
  void set_parent_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ParentId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsShown =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsShown kIsShown() { return {}; }
  void set_is_shown(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsShown::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsDirty =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsDirty kIsDirty() { return {}; }
  void set_is_dirty(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsDirty::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ClassName =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ClassName kClassName() { return {}; }
  void set_class_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ClassName::kFieldId, data, size);
  }
  void set_class_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ClassName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ResourceName =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      AndroidView>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ResourceName kResourceName() { return {}; }
  void set_resource_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ResourceName::kFieldId, data, size);
  }
  void set_resource_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ResourceName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class RenderFrameProxyHost_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RenderFrameProxyHost_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderFrameProxyHost_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderFrameProxyHost_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_routing_id() const { return at<1>().valid(); }
  int32_t routing_id() const { return at<1>().as_int32(); }
  bool has_process_id() const { return at<2>().valid(); }
  int32_t process_id() const { return at<2>().as_int32(); }
  bool has_rvh_map_id() const { return at<3>().valid(); }
  int32_t rvh_map_id() const { return at<3>().as_int32(); }
  bool has_site_instance_id() const { return at<4>().valid(); }
  int32_t site_instance_id() const { return at<4>().as_int32(); }
  bool has_is_render_frame_proxy_live() const { return at<5>().valid(); }
  bool is_render_frame_proxy_live() const { return at<5>().as_bool(); }
  bool has_site_instance_group_id() const { return at<6>().valid(); }
  int32_t site_instance_group_id() const { return at<6>().as_int32(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class RenderFrameProxyHost : public ::protozero::Message {
 public:
  using Decoder = RenderFrameProxyHost_Decoder;
  enum : int32_t {
    kRoutingIdFieldNumber = 1,
    kProcessIdFieldNumber = 2,
    kRvhMapIdFieldNumber = 3,
    kSiteInstanceIdFieldNumber = 4,
    kIsRenderFrameProxyLiveFieldNumber = 5,
    kSiteInstanceGroupIdFieldNumber = 6,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderFrameProxyHost"; }


  using FieldMetadata_RoutingId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RoutingId kRoutingId() { return {}; }
  void set_routing_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RoutingId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ProcessId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProcessId kProcessId() { return {}; }
  void set_process_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ProcessId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RvhMapId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RvhMapId kRvhMapId() { return {}; }
  void set_rvh_map_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RvhMapId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SiteInstanceId =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceId kSiteInstanceId() { return {}; }
  void set_site_instance_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SiteInstanceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsRenderFrameProxyLive =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsRenderFrameProxyLive kIsRenderFrameProxyLive() { return {}; }
  void set_is_render_frame_proxy_live(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsRenderFrameProxyLive::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SiteInstanceGroupId =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceGroupId kSiteInstanceGroupId() { return {}; }
  void set_site_instance_group_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SiteInstanceGroupId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      RenderFrameProxyHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class RenderViewHost_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RenderViewHost_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderViewHost_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderViewHost_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_rvh_map_id() const { return at<1>().valid(); }
  int32_t rvh_map_id() const { return at<1>().as_int32(); }
  bool has_routing_id() const { return at<2>().valid(); }
  int32_t routing_id() const { return at<2>().as_int32(); }
  bool has_process_id() const { return at<3>().valid(); }
  int32_t process_id() const { return at<3>().as_int32(); }
  bool has_process() const { return at<6>().valid(); }
  ::protozero::ConstBytes process() const { return at<6>().as_bytes(); }
  bool has_is_in_back_forward_cache() const { return at<4>().valid(); }
  bool is_in_back_forward_cache() const { return at<4>().as_bool(); }
  bool has_renderer_view_created() const { return at<5>().valid(); }
  bool renderer_view_created() const { return at<5>().as_bool(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class RenderViewHost : public ::protozero::Message {
 public:
  using Decoder = RenderViewHost_Decoder;
  enum : int32_t {
    kRvhMapIdFieldNumber = 1,
    kRoutingIdFieldNumber = 2,
    kProcessIdFieldNumber = 3,
    kProcessFieldNumber = 6,
    kIsInBackForwardCacheFieldNumber = 4,
    kRendererViewCreatedFieldNumber = 5,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderViewHost"; }


  using FieldMetadata_RvhMapId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RvhMapId kRvhMapId() { return {}; }
  void set_rvh_map_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RvhMapId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RoutingId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RoutingId kRoutingId() { return {}; }
  void set_routing_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RoutingId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ProcessId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProcessId kProcessId() { return {}; }
  void set_process_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ProcessId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Process =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHost,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Process kProcess() { return {}; }
  template <typename T = RenderProcessHost> T* set_process() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_IsInBackForwardCache =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsInBackForwardCache kIsInBackForwardCache() { return {}; }
  void set_is_in_back_forward_cache(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsInBackForwardCache::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RendererViewCreated =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RendererViewCreated kRendererViewCreated() { return {}; }
  void set_renderer_view_created(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_RendererViewCreated::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      RenderViewHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class SiteInstanceGroup_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  SiteInstanceGroup_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SiteInstanceGroup_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SiteInstanceGroup_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_site_instance_group_id() const { return at<1>().valid(); }
  int32_t site_instance_group_id() const { return at<1>().as_int32(); }
  bool has_active_frame_count() const { return at<2>().valid(); }
  int32_t active_frame_count() const { return at<2>().as_int32(); }
  bool has_process() const { return at<3>().valid(); }
  ::protozero::ConstBytes process() const { return at<3>().as_bytes(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class SiteInstanceGroup : public ::protozero::Message {
 public:
  using Decoder = SiteInstanceGroup_Decoder;
  enum : int32_t {
    kSiteInstanceGroupIdFieldNumber = 1,
    kActiveFrameCountFieldNumber = 2,
    kProcessFieldNumber = 3,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SiteInstanceGroup"; }


  using FieldMetadata_SiteInstanceGroupId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstanceGroup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceGroupId kSiteInstanceGroupId() { return {}; }
  void set_site_instance_group_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SiteInstanceGroupId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ActiveFrameCount =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstanceGroup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ActiveFrameCount kActiveFrameCount() { return {}; }
  void set_active_frame_count(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ActiveFrameCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Process =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHost,
      SiteInstanceGroup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Process kProcess() { return {}; }
  template <typename T = RenderProcessHost> T* set_process() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      SiteInstanceGroup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class SiteInstance_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  SiteInstance_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SiteInstance_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SiteInstance_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_site_instance_id() const { return at<1>().valid(); }
  int32_t site_instance_id() const { return at<1>().as_int32(); }
  bool has_browsing_instance_id() const { return at<2>().valid(); }
  int32_t browsing_instance_id() const { return at<2>().as_int32(); }
  bool has_is_default() const { return at<3>().valid(); }
  bool is_default() const { return at<3>().as_bool(); }
  bool has_has_process() const { return at<4>().valid(); }
  bool has_process() const { return at<4>().as_bool(); }
  bool has_related_active_contents_count() const { return at<5>().valid(); }
  int32_t related_active_contents_count() const { return at<5>().as_int32(); }
  bool has_active_rfh_count() const { return at<6>().valid(); }
  int32_t active_rfh_count() const { return at<6>().as_int32(); }
  bool has_site_instance_group() const { return at<7>().valid(); }
  ::protozero::ConstBytes site_instance_group() const { return at<7>().as_bytes(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class SiteInstance : public ::protozero::Message {
 public:
  using Decoder = SiteInstance_Decoder;
  enum : int32_t {
    kSiteInstanceIdFieldNumber = 1,
    kBrowsingInstanceIdFieldNumber = 2,
    kIsDefaultFieldNumber = 3,
    kHasProcessFieldNumber = 4,
    kRelatedActiveContentsCountFieldNumber = 5,
    kActiveRfhCountFieldNumber = 6,
    kSiteInstanceGroupFieldNumber = 7,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SiteInstance"; }


  using FieldMetadata_SiteInstanceId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceId kSiteInstanceId() { return {}; }
  void set_site_instance_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SiteInstanceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_BrowsingInstanceId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BrowsingInstanceId kBrowsingInstanceId() { return {}; }
  void set_browsing_instance_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BrowsingInstanceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsDefault =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsDefault kIsDefault() { return {}; }
  void set_is_default(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsDefault::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasProcess =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasProcess kHasProcess() { return {}; }
  void set_has_process(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasProcess::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RelatedActiveContentsCount =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RelatedActiveContentsCount kRelatedActiveContentsCount() { return {}; }
  void set_related_active_contents_count(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RelatedActiveContentsCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ActiveRfhCount =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ActiveRfhCount kActiveRfhCount() { return {}; }
  void set_active_rfh_count(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ActiveRfhCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SiteInstanceGroup =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SiteInstanceGroup,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceGroup kSiteInstanceGroup() { return {}; }
  template <typename T = SiteInstanceGroup> T* set_site_instance_group() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      SiteInstance>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class ChromeExtensionId_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeExtensionId_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeExtensionId_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeExtensionId_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_extension_id() const { return at<1>().valid(); }
  ::protozero::ConstChars extension_id() const { return at<1>().as_string(); }
  bool has_pseudonymized_extension_id() const { return at<2>().valid(); }
  uint32_t pseudonymized_extension_id() const { return at<2>().as_uint32(); }
};

class ChromeExtensionId : public ::protozero::Message {
 public:
  using Decoder = ChromeExtensionId_Decoder;
  enum : int32_t {
    kExtensionIdFieldNumber = 1,
    kPseudonymizedExtensionIdFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeExtensionId"; }


  using FieldMetadata_ExtensionId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeExtensionId>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ExtensionId kExtensionId() { return {}; }
  void set_extension_id(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ExtensionId::kFieldId, data, size);
  }
  void set_extension_id(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ExtensionId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PseudonymizedExtensionId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeExtensionId>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PseudonymizedExtensionId kPseudonymizedExtensionId() { return {}; }
  void set_pseudonymized_extension_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_PseudonymizedExtensionId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class ChildProcessLauncherPriority_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChildProcessLauncherPriority_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChildProcessLauncherPriority_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChildProcessLauncherPriority_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_is_backgrounded() const { return at<1>().valid(); }
  bool is_backgrounded() const { return at<1>().as_bool(); }
  bool has_has_pending_views() const { return at<2>().valid(); }
  bool has_pending_views() const { return at<2>().as_bool(); }
  bool has_importance() const { return at<3>().valid(); }
  int32_t importance() const { return at<3>().as_int32(); }
};

class ChildProcessLauncherPriority : public ::protozero::Message {
 public:
  using Decoder = ChildProcessLauncherPriority_Decoder;
  enum : int32_t {
    kIsBackgroundedFieldNumber = 1,
    kHasPendingViewsFieldNumber = 2,
    kImportanceFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChildProcessLauncherPriority"; }

  using Importance = ::perfetto::protos::pbzero::ChildProcessLauncherPriority_Importance;
  static const Importance IMPORTANCE_NORMAL = ChildProcessLauncherPriority_Importance_IMPORTANCE_NORMAL;
  static const Importance IMPORTANCE_MODERATE = ChildProcessLauncherPriority_Importance_IMPORTANCE_MODERATE;
  static const Importance IMPORTANCE_IMPORTANT = ChildProcessLauncherPriority_Importance_IMPORTANCE_IMPORTANT;

  using FieldMetadata_IsBackgrounded =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChildProcessLauncherPriority>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsBackgrounded kIsBackgrounded() { return {}; }
  void set_is_backgrounded(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsBackgrounded::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasPendingViews =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChildProcessLauncherPriority>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasPendingViews kHasPendingViews() { return {}; }
  void set_has_pending_views(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasPendingViews::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Importance =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChildProcessLauncherPriority_Importance,
      ChildProcessLauncherPriority>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Importance kImportance() { return {}; }
  void set_importance(::perfetto::protos::pbzero::ChildProcessLauncherPriority_Importance value) {
    static constexpr uint32_t field_id = FieldMetadata_Importance::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class RenderProcessHostCleanup_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RenderProcessHostCleanup_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderProcessHostCleanup_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderProcessHostCleanup_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_listener_count() const { return at<1>().valid(); }
  uint32_t listener_count() const { return at<1>().as_uint32(); }
  bool has_keep_alive_ref_count() const { return at<2>().valid(); }
  uint32_t keep_alive_ref_count() const { return at<2>().as_uint32(); }
  bool has_shutdown_delay_ref_count() const { return at<3>().valid(); }
  uint32_t shutdown_delay_ref_count() const { return at<3>().as_uint32(); }
  bool has_worker_ref_count() const { return at<4>().valid(); }
  uint32_t worker_ref_count() const { return at<4>().as_uint32(); }
};

class RenderProcessHostCleanup : public ::protozero::Message {
 public:
  using Decoder = RenderProcessHostCleanup_Decoder;
  enum : int32_t {
    kListenerCountFieldNumber = 1,
    kKeepAliveRefCountFieldNumber = 2,
    kShutdownDelayRefCountFieldNumber = 3,
    kWorkerRefCountFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderProcessHostCleanup"; }


  using FieldMetadata_ListenerCount =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHostCleanup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ListenerCount kListenerCount() { return {}; }
  void set_listener_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ListenerCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeepAliveRefCount =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHostCleanup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KeepAliveRefCount kKeepAliveRefCount() { return {}; }
  void set_keep_alive_ref_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_KeepAliveRefCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShutdownDelayRefCount =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHostCleanup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ShutdownDelayRefCount kShutdownDelayRefCount() { return {}; }
  void set_shutdown_delay_ref_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ShutdownDelayRefCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WorkerRefCount =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHostCleanup>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WorkerRefCount kWorkerRefCount() { return {}; }
  void set_worker_ref_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_WorkerRefCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class RenderProcessHostListener_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RenderProcessHostListener_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderProcessHostListener_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderProcessHostListener_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_routing_id() const { return at<1>().valid(); }
  uint32_t routing_id() const { return at<1>().as_uint32(); }
};

class RenderProcessHostListener : public ::protozero::Message {
 public:
  using Decoder = RenderProcessHostListener_Decoder;
  enum : int32_t {
    kRoutingIdFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderProcessHostListener"; }


  using FieldMetadata_RoutingId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHostListener>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RoutingId kRoutingId() { return {}; }
  void set_routing_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RoutingId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class RenderProcessHost_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RenderProcessHost_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderProcessHost_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderProcessHost_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint32_t id() const { return at<1>().as_uint32(); }
  bool has_process_lock() const { return at<2>().valid(); }
  ::protozero::ConstChars process_lock() const { return at<2>().as_string(); }
  bool has_child_process_id() const { return at<3>().valid(); }
  int32_t child_process_id() const { return at<3>().as_int32(); }
  bool has_browser_context() const { return at<4>().valid(); }
  ::protozero::ConstBytes browser_context() const { return at<4>().as_bytes(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class RenderProcessHost : public ::protozero::Message {
 public:
  using Decoder = RenderProcessHost_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kProcessLockFieldNumber = 2,
    kChildProcessIdFieldNumber = 3,
    kBrowserContextFieldNumber = 4,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderProcessHost"; }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      RenderProcessHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Id kId() { return {}; }
  void set_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ProcessLock =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      RenderProcessHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProcessLock kProcessLock() { return {}; }
  void set_process_lock(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ProcessLock::kFieldId, data, size);
  }
  void set_process_lock(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ProcessLock::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ChildProcessId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RenderProcessHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChildProcessId kChildProcessId() { return {}; }
  void set_child_process_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ChildProcessId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_BrowserContext =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeBrowserContext,
      RenderProcessHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BrowserContext kBrowserContext() { return {}; }
  template <typename T = ChromeBrowserContext> T* set_browser_context() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      RenderProcessHost>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class ResourceBundle_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ResourceBundle_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ResourceBundle_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ResourceBundle_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_resource_id() const { return at<1>().valid(); }
  uint32_t resource_id() const { return at<1>().as_uint32(); }
};

class ResourceBundle : public ::protozero::Message {
 public:
  using Decoder = ResourceBundle_Decoder;
  enum : int32_t {
    kResourceIdFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ResourceBundle"; }


  using FieldMetadata_ResourceId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ResourceBundle>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ResourceId kResourceId() { return {}; }
  void set_resource_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ResourceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class ChromeWebAppBadNavigate_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeWebAppBadNavigate_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeWebAppBadNavigate_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeWebAppBadNavigate_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_is_kiosk() const { return at<1>().valid(); }
  bool is_kiosk() const { return at<1>().as_bool(); }
  bool has_has_hosted_app_controller() const { return at<2>().valid(); }
  bool has_hosted_app_controller() const { return at<2>().as_bool(); }
  bool has_app_name() const { return at<3>().valid(); }
  ::protozero::ConstChars app_name() const { return at<3>().as_string(); }
  bool has_system_app_type() const { return at<4>().valid(); }
  uint32_t system_app_type() const { return at<4>().as_uint32(); }
  bool has_web_app_provider_registry_ready() const { return at<5>().valid(); }
  bool web_app_provider_registry_ready() const { return at<5>().as_bool(); }
  bool has_system_web_app_manager_synchronized() const { return at<6>().valid(); }
  bool system_web_app_manager_synchronized() const { return at<6>().as_bool(); }
};

class ChromeWebAppBadNavigate : public ::protozero::Message {
 public:
  using Decoder = ChromeWebAppBadNavigate_Decoder;
  enum : int32_t {
    kIsKioskFieldNumber = 1,
    kHasHostedAppControllerFieldNumber = 2,
    kAppNameFieldNumber = 3,
    kSystemAppTypeFieldNumber = 4,
    kWebAppProviderRegistryReadyFieldNumber = 5,
    kSystemWebAppManagerSynchronizedFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeWebAppBadNavigate"; }


  using FieldMetadata_IsKiosk =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsKiosk kIsKiosk() { return {}; }
  void set_is_kiosk(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsKiosk::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasHostedAppController =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasHostedAppController kHasHostedAppController() { return {}; }
  void set_has_hosted_app_controller(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasHostedAppController::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AppName =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AppName kAppName() { return {}; }
  void set_app_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_AppName::kFieldId, data, size);
  }
  void set_app_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_AppName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SystemAppType =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SystemAppType kSystemAppType() { return {}; }
  void set_system_app_type(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SystemAppType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WebAppProviderRegistryReady =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WebAppProviderRegistryReady kWebAppProviderRegistryReady() { return {}; }
  void set_web_app_provider_registry_ready(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_WebAppProviderRegistryReady::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SystemWebAppManagerSynchronized =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeWebAppBadNavigate>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SystemWebAppManagerSynchronized kSystemWebAppManagerSynchronized() { return {}; }
  void set_system_web_app_manager_synchronized(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_SystemWebAppManagerSynchronized::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class ChromeHashedPerformanceMark_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeHashedPerformanceMark_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeHashedPerformanceMark_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeHashedPerformanceMark_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_site_hash() const { return at<1>().valid(); }
  uint32_t site_hash() const { return at<1>().as_uint32(); }
  bool has_site() const { return at<2>().valid(); }
  ::protozero::ConstChars site() const { return at<2>().as_string(); }
  bool has_mark_hash() const { return at<3>().valid(); }
  uint32_t mark_hash() const { return at<3>().as_uint32(); }
  bool has_mark() const { return at<4>().valid(); }
  ::protozero::ConstChars mark() const { return at<4>().as_string(); }
  bool has_execution_context_id() const { return at<5>().valid(); }
  uint32_t execution_context_id() const { return at<5>().as_uint32(); }
  bool has_sequence_number() const { return at<6>().valid(); }
  uint32_t sequence_number() const { return at<6>().as_uint32(); }
};

class ChromeHashedPerformanceMark : public ::protozero::Message {
 public:
  using Decoder = ChromeHashedPerformanceMark_Decoder;
  enum : int32_t {
    kSiteHashFieldNumber = 1,
    kSiteFieldNumber = 2,
    kMarkHashFieldNumber = 3,
    kMarkFieldNumber = 4,
    kExecutionContextIdFieldNumber = 5,
    kSequenceNumberFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeHashedPerformanceMark"; }


  using FieldMetadata_SiteHash =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteHash kSiteHash() { return {}; }
  void set_site_hash(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SiteHash::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Site =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Site kSite() { return {}; }
  void set_site(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Site::kFieldId, data, size);
  }
  void set_site(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Site::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MarkHash =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MarkHash kMarkHash() { return {}; }
  void set_mark_hash(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MarkHash::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Mark =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Mark kMark() { return {}; }
  void set_mark(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Mark::kFieldId, data, size);
  }
  void set_mark(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Mark::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ExecutionContextId =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ExecutionContextId kExecutionContextId() { return {}; }
  void set_execution_context_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ExecutionContextId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SequenceNumber =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeHashedPerformanceMark>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SequenceNumber kSequenceNumber() { return {}; }
  void set_sequence_number(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SequenceNumber::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class FrameTreeNodeInfo_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/99, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FrameTreeNodeInfo_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FrameTreeNodeInfo_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FrameTreeNodeInfo_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_frame_tree_node_id() const { return at<1>().valid(); }
  uint64_t frame_tree_node_id() const { return at<1>().as_uint64(); }
  bool has_is_main_frame() const { return at<2>().valid(); }
  bool is_main_frame() const { return at<2>().as_bool(); }
  bool has_has_speculative_render_frame_host() const { return at<3>().valid(); }
  bool has_speculative_render_frame_host() const { return at<3>().as_bool(); }
  bool has_current_frame_host() const { return at<4>().valid(); }
  ::protozero::ConstBytes current_frame_host() const { return at<4>().as_bytes(); }
  bool has_speculative_frame_host() const { return at<5>().valid(); }
  ::protozero::ConstBytes speculative_frame_host() const { return at<5>().as_bytes(); }
  bool has_debug_annotations() const { return at<99>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(99); }
};

class FrameTreeNodeInfo : public ::protozero::Message {
 public:
  using Decoder = FrameTreeNodeInfo_Decoder;
  enum : int32_t {
    kFrameTreeNodeIdFieldNumber = 1,
    kIsMainFrameFieldNumber = 2,
    kHasSpeculativeRenderFrameHostFieldNumber = 3,
    kCurrentFrameHostFieldNumber = 4,
    kSpeculativeFrameHostFieldNumber = 5,
    kDebugAnnotationsFieldNumber = 99,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FrameTreeNodeInfo"; }


  using FieldMetadata_FrameTreeNodeId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNodeId kFrameTreeNodeId() { return {}; }
  void set_frame_tree_node_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameTreeNodeId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsMainFrame =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsMainFrame kIsMainFrame() { return {}; }
  void set_is_main_frame(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsMainFrame::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasSpeculativeRenderFrameHost =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasSpeculativeRenderFrameHost kHasSpeculativeRenderFrameHost() { return {}; }
  void set_has_speculative_render_frame_host(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasSpeculativeRenderFrameHost::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CurrentFrameHost =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CurrentFrameHost kCurrentFrameHost() { return {}; }
  template <typename T = RenderFrameHost> T* set_current_frame_host() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_SpeculativeFrameHost =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SpeculativeFrameHost kSpeculativeFrameHost() { return {}; }
  template <typename T = RenderFrameHost> T* set_speculative_frame_host() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_DebugAnnotations =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DebugAnnotation,
      FrameTreeNodeInfo>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DebugAnnotations kDebugAnnotations() { return {}; }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(99);
  }

};

class ShouldSwapBrowsingInstancesResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ShouldSwapBrowsingInstancesResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ShouldSwapBrowsingInstancesResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ShouldSwapBrowsingInstancesResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_frame_tree_node_id() const { return at<1>().valid(); }
  uint64_t frame_tree_node_id() const { return at<1>().as_uint64(); }
  bool has_result() const { return at<2>().valid(); }
  int32_t result() const { return at<2>().as_int32(); }
};

class ShouldSwapBrowsingInstancesResult : public ::protozero::Message {
 public:
  using Decoder = ShouldSwapBrowsingInstancesResult_Decoder;
  enum : int32_t {
    kFrameTreeNodeIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ShouldSwapBrowsingInstancesResult"; }


  using FieldMetadata_FrameTreeNodeId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ShouldSwapBrowsingInstancesResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNodeId kFrameTreeNodeId() { return {}; }
  void set_frame_tree_node_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameTreeNodeId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Result =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ShouldSwapBrowsingInstance,
      ShouldSwapBrowsingInstancesResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Result kResult() { return {}; }
  void set_result(::perfetto::protos::pbzero::ShouldSwapBrowsingInstance value) {
    static constexpr uint32_t field_id = FieldMetadata_Result::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class RenderFrameImplDeletion_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RenderFrameImplDeletion_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RenderFrameImplDeletion_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RenderFrameImplDeletion_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_intent() const { return at<1>().valid(); }
  int32_t intent() const { return at<1>().as_int32(); }
  bool has_has_pending_commit() const { return at<2>().valid(); }
  bool has_pending_commit() const { return at<2>().as_bool(); }
  bool has_has_pending_cross_document_commit() const { return at<3>().valid(); }
  bool has_pending_cross_document_commit() const { return at<3>().as_bool(); }
  bool has_frame_tree_node_id() const { return at<4>().valid(); }
  uint64_t frame_tree_node_id() const { return at<4>().as_uint64(); }
};

class RenderFrameImplDeletion : public ::protozero::Message {
 public:
  using Decoder = RenderFrameImplDeletion_Decoder;
  enum : int32_t {
    kIntentFieldNumber = 1,
    kHasPendingCommitFieldNumber = 2,
    kHasPendingCrossDocumentCommitFieldNumber = 3,
    kFrameTreeNodeIdFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RenderFrameImplDeletion"; }


  using FieldMetadata_Intent =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::FrameDeleteIntention,
      RenderFrameImplDeletion>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Intent kIntent() { return {}; }
  void set_intent(::perfetto::protos::pbzero::FrameDeleteIntention value) {
    static constexpr uint32_t field_id = FieldMetadata_Intent::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasPendingCommit =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RenderFrameImplDeletion>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasPendingCommit kHasPendingCommit() { return {}; }
  void set_has_pending_commit(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasPendingCommit::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasPendingCrossDocumentCommit =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RenderFrameImplDeletion>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HasPendingCrossDocumentCommit kHasPendingCrossDocumentCommit() { return {}; }
  void set_has_pending_cross_document_commit(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasPendingCrossDocumentCommit::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrameTreeNodeId =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      RenderFrameImplDeletion>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNodeId kFrameTreeNodeId() { return {}; }
  void set_frame_tree_node_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameTreeNodeId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class ChromeMessagePumpForUI_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeMessagePumpForUI_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeMessagePumpForUI_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeMessagePumpForUI_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_message_id() const { return at<1>().valid(); }
  uint32_t message_id() const { return at<1>().as_uint32(); }
};

class ChromeMessagePumpForUI : public ::protozero::Message {
 public:
  using Decoder = ChromeMessagePumpForUI_Decoder;
  enum : int32_t {
    kMessageIdFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeMessagePumpForUI"; }


  using FieldMetadata_MessageId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeMessagePumpForUI>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MessageId kMessageId() { return {}; }
  void set_message_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MessageId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class ChromeRasterTask_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeRasterTask_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeRasterTask_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeRasterTask_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_source_frame_number() const { return at<1>().valid(); }
  int64_t source_frame_number() const { return at<1>().as_int64(); }
};

class ChromeRasterTask : public ::protozero::Message {
 public:
  using Decoder = ChromeRasterTask_Decoder;
  enum : int32_t {
    kSourceFrameNumberFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeRasterTask"; }


  using FieldMetadata_SourceFrameNumber =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      ChromeRasterTask>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SourceFrameNumber kSourceFrameNumber() { return {}; }
  void set_source_frame_number(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SourceFrameNumber::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class ChromeTaskPostedToDisabledQueue_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeTaskPostedToDisabledQueue_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeTaskPostedToDisabledQueue_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeTaskPostedToDisabledQueue_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_task_queue_name() const { return at<1>().valid(); }
  ::protozero::ConstChars task_queue_name() const { return at<1>().as_string(); }
  bool has_time_since_disabled_ms() const { return at<2>().valid(); }
  uint64_t time_since_disabled_ms() const { return at<2>().as_uint64(); }
  bool has_ipc_hash() const { return at<3>().valid(); }
  uint32_t ipc_hash() const { return at<3>().as_uint32(); }
  bool has_source_location_iid() const { return at<4>().valid(); }
  uint64_t source_location_iid() const { return at<4>().as_uint64(); }
};

class ChromeTaskPostedToDisabledQueue : public ::protozero::Message {
 public:
  using Decoder = ChromeTaskPostedToDisabledQueue_Decoder;
  enum : int32_t {
    kTaskQueueNameFieldNumber = 1,
    kTimeSinceDisabledMsFieldNumber = 2,
    kIpcHashFieldNumber = 3,
    kSourceLocationIidFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeTaskPostedToDisabledQueue"; }


  using FieldMetadata_TaskQueueName =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeTaskPostedToDisabledQueue>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TaskQueueName kTaskQueueName() { return {}; }
  void set_task_queue_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_TaskQueueName::kFieldId, data, size);
  }
  void set_task_queue_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_TaskQueueName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TimeSinceDisabledMs =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ChromeTaskPostedToDisabledQueue>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TimeSinceDisabledMs kTimeSinceDisabledMs() { return {}; }
  void set_time_since_disabled_ms(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TimeSinceDisabledMs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IpcHash =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeTaskPostedToDisabledQueue>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IpcHash kIpcHash() { return {}; }
  void set_ipc_hash(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_IpcHash::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SourceLocationIid =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ChromeTaskPostedToDisabledQueue>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SourceLocationIid kSourceLocationIid() { return {}; }
  void set_source_location_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SourceLocationIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class ChromeProfileDestroyer_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeProfileDestroyer_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeProfileDestroyer_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeProfileDestroyer_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_profile_ptr() const { return at<1>().valid(); }
  uint64_t profile_ptr() const { return at<1>().as_uint64(); }
  bool has_is_off_the_record() const { return at<2>().valid(); }
  bool is_off_the_record() const { return at<2>().as_bool(); }
  bool has_otr_profile_id() const { return at<3>().valid(); }
  ::protozero::ConstChars otr_profile_id() const { return at<3>().as_string(); }
  bool has_host_count_at_creation() const { return at<4>().valid(); }
  uint32_t host_count_at_creation() const { return at<4>().as_uint32(); }
  bool has_host_count_at_destruction() const { return at<5>().valid(); }
  uint32_t host_count_at_destruction() const { return at<5>().as_uint32(); }
  bool has_render_process_host_ptr() const { return at<6>().valid(); }
  uint64_t render_process_host_ptr() const { return at<6>().as_uint64(); }
};

class ChromeProfileDestroyer : public ::protozero::Message {
 public:
  using Decoder = ChromeProfileDestroyer_Decoder;
  enum : int32_t {
    kProfilePtrFieldNumber = 1,
    kIsOffTheRecordFieldNumber = 2,
    kOtrProfileIdFieldNumber = 3,
    kHostCountAtCreationFieldNumber = 4,
    kHostCountAtDestructionFieldNumber = 5,
    kRenderProcessHostPtrFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeProfileDestroyer"; }


  using FieldMetadata_ProfilePtr =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProfilePtr kProfilePtr() { return {}; }
  void set_profile_ptr(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ProfilePtr::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFixed64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsOffTheRecord =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsOffTheRecord kIsOffTheRecord() { return {}; }
  void set_is_off_the_record(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsOffTheRecord::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OtrProfileId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_OtrProfileId kOtrProfileId() { return {}; }
  void set_otr_profile_id(const char* data, size_t size) {
    AppendBytes(FieldMetadata_OtrProfileId::kFieldId, data, size);
  }
  void set_otr_profile_id(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_OtrProfileId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HostCountAtCreation =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HostCountAtCreation kHostCountAtCreation() { return {}; }
  void set_host_count_at_creation(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_HostCountAtCreation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HostCountAtDestruction =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HostCountAtDestruction kHostCountAtDestruction() { return {}; }
  void set_host_count_at_destruction(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_HostCountAtDestruction::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RenderProcessHostPtr =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      ChromeProfileDestroyer>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderProcessHostPtr kRenderProcessHostPtr() { return {}; }
  void set_render_process_host_ptr(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RenderProcessHostPtr::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFixed64>
        ::Append(*this, field_id, value);
  }
};

class ChromeBrowserContext_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeBrowserContext_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeBrowserContext_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeBrowserContext_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<2>().valid(); }
  ::protozero::ConstChars id() const { return at<2>().as_string(); }
};

class ChromeBrowserContext : public ::protozero::Message {
 public:
  using Decoder = ChromeBrowserContext_Decoder;
  enum : int32_t {
    kIdFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeBrowserContext"; }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ChromeBrowserContext>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Id kId() { return {}; }
  void set_id(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Id::kFieldId, data, size);
  }
  void set_id(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class ChromeTaskAnnotator_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeTaskAnnotator_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeTaskAnnotator_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeTaskAnnotator_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ipc_hash() const { return at<1>().valid(); }
  uint32_t ipc_hash() const { return at<1>().as_uint32(); }
  bool has_task_delay_us() const { return at<2>().valid(); }
  uint64_t task_delay_us() const { return at<2>().as_uint64(); }
};

class ChromeTaskAnnotator : public ::protozero::Message {
 public:
  using Decoder = ChromeTaskAnnotator_Decoder;
  enum : int32_t {
    kIpcHashFieldNumber = 1,
    kTaskDelayUsFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeTaskAnnotator"; }


  using FieldMetadata_IpcHash =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ChromeTaskAnnotator>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IpcHash kIpcHash() { return {}; }
  void set_ipc_hash(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_IpcHash::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TaskDelayUs =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ChromeTaskAnnotator>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TaskDelayUs kTaskDelayUs() { return {}; }
  void set_task_delay_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TaskDelayUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class ChromeMemoryPressureNotification_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeMemoryPressureNotification_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeMemoryPressureNotification_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeMemoryPressureNotification_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_level() const { return at<1>().valid(); }
  int32_t level() const { return at<1>().as_int32(); }
  bool has_creation_location_iid() const { return at<2>().valid(); }
  uint64_t creation_location_iid() const { return at<2>().as_uint64(); }
};

class ChromeMemoryPressureNotification : public ::protozero::Message {
 public:
  using Decoder = ChromeMemoryPressureNotification_Decoder;
  enum : int32_t {
    kLevelFieldNumber = 1,
    kCreationLocationIidFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeMemoryPressureNotification"; }


  using FieldMetadata_Level =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::MemoryPressureLevel,
      ChromeMemoryPressureNotification>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Level kLevel() { return {}; }
  void set_level(::perfetto::protos::pbzero::MemoryPressureLevel value) {
    static constexpr uint32_t field_id = FieldMetadata_Level::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CreationLocationIid =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ChromeMemoryPressureNotification>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CreationLocationIid kCreationLocationIid() { return {}; }
  void set_creation_location_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CreationLocationIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class ChromeTrackEvent : public ::perfetto::protos::pbzero::TrackEvent {
 public:

  using FieldMetadata_ChromeAppState =
    ::protozero::proto_utils::FieldMetadata<
      1000,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ChromeAppState,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeAppState kChromeAppState() { return {}; }
  void set_chrome_app_state(::perfetto::protos::pbzero::ChromeAppState value) {
    static constexpr uint32_t field_id = FieldMetadata_ChromeAppState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ChromeMemoryPressureNotification =
    ::protozero::proto_utils::FieldMetadata<
      1001,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeMemoryPressureNotification,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeMemoryPressureNotification kChromeMemoryPressureNotification() { return {}; }
  template <typename T = ChromeMemoryPressureNotification> T* set_chrome_memory_pressure_notification() {
    return BeginNestedMessage<T>(1001);
  }


  using FieldMetadata_ChromeTaskAnnotator =
    ::protozero::proto_utils::FieldMetadata<
      1002,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeTaskAnnotator,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeTaskAnnotator kChromeTaskAnnotator() { return {}; }
  template <typename T = ChromeTaskAnnotator> T* set_chrome_task_annotator() {
    return BeginNestedMessage<T>(1002);
  }


  using FieldMetadata_ChromeBrowserContext =
    ::protozero::proto_utils::FieldMetadata<
      1003,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeBrowserContext,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeBrowserContext kChromeBrowserContext() { return {}; }
  template <typename T = ChromeBrowserContext> T* set_chrome_browser_context() {
    return BeginNestedMessage<T>(1003);
  }


  using FieldMetadata_ChromeProfileDestroyer =
    ::protozero::proto_utils::FieldMetadata<
      1004,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeProfileDestroyer,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeProfileDestroyer kChromeProfileDestroyer() { return {}; }
  template <typename T = ChromeProfileDestroyer> T* set_chrome_profile_destroyer() {
    return BeginNestedMessage<T>(1004);
  }


  using FieldMetadata_ChromeTaskPostedToDisabledQueue =
    ::protozero::proto_utils::FieldMetadata<
      1005,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeTaskPostedToDisabledQueue,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeTaskPostedToDisabledQueue kChromeTaskPostedToDisabledQueue() { return {}; }
  template <typename T = ChromeTaskPostedToDisabledQueue> T* set_chrome_task_posted_to_disabled_queue() {
    return BeginNestedMessage<T>(1005);
  }


  using FieldMetadata_ChromeRasterTask =
    ::protozero::proto_utils::FieldMetadata<
      1006,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeRasterTask,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeRasterTask kChromeRasterTask() { return {}; }
  template <typename T = ChromeRasterTask> T* set_chrome_raster_task() {
    return BeginNestedMessage<T>(1006);
  }


  using FieldMetadata_ChromeMessagePumpForUi =
    ::protozero::proto_utils::FieldMetadata<
      1007,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeMessagePumpForUI,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeMessagePumpForUi kChromeMessagePumpForUi() { return {}; }
  template <typename T = ChromeMessagePumpForUI> T* set_chrome_message_pump_for_ui() {
    return BeginNestedMessage<T>(1007);
  }


  using FieldMetadata_RenderFrameImplDeletion =
    ::protozero::proto_utils::FieldMetadata<
      1008,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameImplDeletion,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderFrameImplDeletion kRenderFrameImplDeletion() { return {}; }
  template <typename T = RenderFrameImplDeletion> T* set_render_frame_impl_deletion() {
    return BeginNestedMessage<T>(1008);
  }


  using FieldMetadata_ShouldSwapBrowsingInstancesResult =
    ::protozero::proto_utils::FieldMetadata<
      1009,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ShouldSwapBrowsingInstancesResult,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ShouldSwapBrowsingInstancesResult kShouldSwapBrowsingInstancesResult() { return {}; }
  template <typename T = ShouldSwapBrowsingInstancesResult> T* set_should_swap_browsing_instances_result() {
    return BeginNestedMessage<T>(1009);
  }


  using FieldMetadata_FrameTreeNodeInfo =
    ::protozero::proto_utils::FieldMetadata<
      1010,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FrameTreeNodeInfo,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameTreeNodeInfo kFrameTreeNodeInfo() { return {}; }
  template <typename T = FrameTreeNodeInfo> T* set_frame_tree_node_info() {
    return BeginNestedMessage<T>(1010);
  }


  using FieldMetadata_ChromeHashedPerformanceMark =
    ::protozero::proto_utils::FieldMetadata<
      1011,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeHashedPerformanceMark,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeHashedPerformanceMark kChromeHashedPerformanceMark() { return {}; }
  template <typename T = ChromeHashedPerformanceMark> T* set_chrome_hashed_performance_mark() {
    return BeginNestedMessage<T>(1011);
  }


  using FieldMetadata_RenderProcessHost =
    ::protozero::proto_utils::FieldMetadata<
      1012,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHost,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderProcessHost kRenderProcessHost() { return {}; }
  template <typename T = RenderProcessHost> T* set_render_process_host() {
    return BeginNestedMessage<T>(1012);
  }


  using FieldMetadata_RenderProcessHostCleanup =
    ::protozero::proto_utils::FieldMetadata<
      1013,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHostCleanup,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderProcessHostCleanup kRenderProcessHostCleanup() { return {}; }
  template <typename T = RenderProcessHostCleanup> T* set_render_process_host_cleanup() {
    return BeginNestedMessage<T>(1013);
  }


  using FieldMetadata_RenderProcessHostListenerChanged =
    ::protozero::proto_utils::FieldMetadata<
      1014,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderProcessHostListener,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderProcessHostListenerChanged kRenderProcessHostListenerChanged() { return {}; }
  template <typename T = RenderProcessHostListener> T* set_render_process_host_listener_changed() {
    return BeginNestedMessage<T>(1014);
  }


  using FieldMetadata_ChildProcessLauncherPriority =
    ::protozero::proto_utils::FieldMetadata<
      1015,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChildProcessLauncherPriority,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChildProcessLauncherPriority kChildProcessLauncherPriority() { return {}; }
  template <typename T = ChildProcessLauncherPriority> T* set_child_process_launcher_priority() {
    return BeginNestedMessage<T>(1015);
  }


  using FieldMetadata_ResourceBundle =
    ::protozero::proto_utils::FieldMetadata<
      1016,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ResourceBundle,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ResourceBundle kResourceBundle() { return {}; }
  template <typename T = ResourceBundle> T* set_resource_bundle() {
    return BeginNestedMessage<T>(1016);
  }


  using FieldMetadata_ChromeWebAppBadNavigate =
    ::protozero::proto_utils::FieldMetadata<
      1017,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeWebAppBadNavigate,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeWebAppBadNavigate kChromeWebAppBadNavigate() { return {}; }
  template <typename T = ChromeWebAppBadNavigate> T* set_chrome_web_app_bad_navigate() {
    return BeginNestedMessage<T>(1017);
  }


  using FieldMetadata_ChromeExtensionId =
    ::protozero::proto_utils::FieldMetadata<
      1018,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeExtensionId,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeExtensionId kChromeExtensionId() { return {}; }
  template <typename T = ChromeExtensionId> T* set_chrome_extension_id() {
    return BeginNestedMessage<T>(1018);
  }


  using FieldMetadata_SiteInstance =
    ::protozero::proto_utils::FieldMetadata<
      1019,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SiteInstance,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstance kSiteInstance() { return {}; }
  template <typename T = SiteInstance> T* set_site_instance() {
    return BeginNestedMessage<T>(1019);
  }


  using FieldMetadata_RenderViewHost =
    ::protozero::proto_utils::FieldMetadata<
      1020,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderViewHost,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderViewHost kRenderViewHost() { return {}; }
  template <typename T = RenderViewHost> T* set_render_view_host() {
    return BeginNestedMessage<T>(1020);
  }


  using FieldMetadata_RenderFrameProxyHost =
    ::protozero::proto_utils::FieldMetadata<
      1021,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameProxyHost,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderFrameProxyHost kRenderFrameProxyHost() { return {}; }
  template <typename T = RenderFrameProxyHost> T* set_render_frame_proxy_host() {
    return BeginNestedMessage<T>(1021);
  }


  using FieldMetadata_AndroidViewDump =
    ::protozero::proto_utils::FieldMetadata<
      1022,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AndroidViewDump,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AndroidViewDump kAndroidViewDump() { return {}; }
  template <typename T = AndroidViewDump> T* set_android_view_dump() {
    return BeginNestedMessage<T>(1022);
  }


  using FieldMetadata_ParkableStringCompressInBackground =
    ::protozero::proto_utils::FieldMetadata<
      1023,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ParkableStringCompressInBackground,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ParkableStringCompressInBackground kParkableStringCompressInBackground() { return {}; }
  template <typename T = ParkableStringCompressInBackground> T* set_parkable_string_compress_in_background() {
    return BeginNestedMessage<T>(1023);
  }


  using FieldMetadata_ParkableStringUnpark =
    ::protozero::proto_utils::FieldMetadata<
      1024,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ParkableStringUnpark,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ParkableStringUnpark kParkableStringUnpark() { return {}; }
  template <typename T = ParkableStringUnpark> T* set_parkable_string_unpark() {
    return BeginNestedMessage<T>(1024);
  }


  using FieldMetadata_ChromeSamplingProfilerSampleCompleted =
    ::protozero::proto_utils::FieldMetadata<
      1025,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeSamplingProfilerSampleCollected,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ChromeSamplingProfilerSampleCompleted kChromeSamplingProfilerSampleCompleted() { return {}; }
  template <typename T = ChromeSamplingProfilerSampleCollected> T* set_chrome_sampling_profiler_sample_completed() {
    return BeginNestedMessage<T>(1025);
  }


  using FieldMetadata_SendBeginMainframeToCommitBreakdown =
    ::protozero::proto_utils::FieldMetadata<
      1026,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SendBeginMainFrameToCommitBreakdown,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SendBeginMainframeToCommitBreakdown kSendBeginMainframeToCommitBreakdown() { return {}; }
  template <typename T = SendBeginMainFrameToCommitBreakdown> T* set_send_begin_mainframe_to_commit_breakdown() {
    return BeginNestedMessage<T>(1026);
  }


  using FieldMetadata_GlobalRenderFrameHostId =
    ::protozero::proto_utils::FieldMetadata<
      1027,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      GlobalRenderFrameHostId,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_GlobalRenderFrameHostId kGlobalRenderFrameHostId() { return {}; }
  template <typename T = GlobalRenderFrameHostId> T* set_global_render_frame_host_id() {
    return BeginNestedMessage<T>(1027);
  }


  using FieldMetadata_RenderFrameHost =
    ::protozero::proto_utils::FieldMetadata<
      1028,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RenderFrameHost,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RenderFrameHost kRenderFrameHost() { return {}; }
  template <typename T = RenderFrameHost> T* set_render_frame_host() {
    return BeginNestedMessage<T>(1028);
  }


  using FieldMetadata_ThreadPoolTask =
    ::protozero::proto_utils::FieldMetadata<
      1029,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeThreadPoolTask,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ThreadPoolTask kThreadPoolTask() { return {}; }
  template <typename T = ChromeThreadPoolTask> T* set_thread_pool_task() {
    return BeginNestedMessage<T>(1029);
  }


  using FieldMetadata_BackForwardCacheCanStoreDocumentResult =
    ::protozero::proto_utils::FieldMetadata<
      1030,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BackForwardCacheCanStoreDocumentResult,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BackForwardCacheCanStoreDocumentResult kBackForwardCacheCanStoreDocumentResult() { return {}; }
  template <typename T = BackForwardCacheCanStoreDocumentResult> T* set_back_forward_cache_can_store_document_result() {
    return BeginNestedMessage<T>(1030);
  }


  using FieldMetadata_RendererMainThreadTaskExecution =
    ::protozero::proto_utils::FieldMetadata<
      1031,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RendererMainThreadTaskExecution,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RendererMainThreadTaskExecution kRendererMainThreadTaskExecution() { return {}; }
  template <typename T = RendererMainThreadTaskExecution> T* set_renderer_main_thread_task_execution() {
    return BeginNestedMessage<T>(1031);
  }


  using FieldMetadata_EventLatency =
    ::protozero::proto_utils::FieldMetadata<
      1032,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      EventLatency,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_EventLatency kEventLatency() { return {}; }
  template <typename T = EventLatency> T* set_event_latency() {
    return BeginNestedMessage<T>(1032);
  }


  using FieldMetadata_ProcessSingleton =
    ::protozero::proto_utils::FieldMetadata<
      1033,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ProcessSingleton,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ProcessSingleton kProcessSingleton() { return {}; }
  template <typename T = ProcessSingleton> T* set_process_singleton() {
    return BeginNestedMessage<T>(1033);
  }


  using FieldMetadata_SiteInstanceGroup =
    ::protozero::proto_utils::FieldMetadata<
      1034,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SiteInstanceGroup,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SiteInstanceGroup kSiteInstanceGroup() { return {}; }
  template <typename T = SiteInstanceGroup> T* set_site_instance_group() {
    return BeginNestedMessage<T>(1034);
  }


  using FieldMetadata_BrowsingContextState =
    ::protozero::proto_utils::FieldMetadata<
      1035,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BrowsingContextState,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BrowsingContextState kBrowsingContextState() { return {}; }
  template <typename T = BrowsingContextState> T* set_browsing_context_state() {
    return BeginNestedMessage<T>(1035);
  }


  using FieldMetadata_DeviceThermalState =
    ::protozero::proto_utils::FieldMetadata<
      1036,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::DeviceThermalState,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DeviceThermalState kDeviceThermalState() { return {}; }
  void set_device_thermal_state(::perfetto::protos::pbzero::DeviceThermalState value) {
    static constexpr uint32_t field_id = FieldMetadata_DeviceThermalState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Navigation =
    ::protozero::proto_utils::FieldMetadata<
      1037,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      NavigationHandle,
      ChromeTrackEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Navigation kNavigation() { return {}; }
  template <typename T = NavigationHandle> T* set_navigation() {
    return BeginNestedMessage<T>(1037);
  }

};
} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
